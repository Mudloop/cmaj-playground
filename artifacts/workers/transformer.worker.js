var x0=Object.defineProperty;var y0=(Q,q)=>{for(var U in q)x0(Q,U,{get:q[U],enumerable:!0,configurable:!0,set:(X)=>q[U]=()=>X})};var v0=(Q,q)=>()=>(Q&&(q=Q(Q=0)),q);var p0=((Q)=>typeof require!=="undefined"?require:typeof Proxy!=="undefined"?new Proxy(Q,{get:(q,U)=>(typeof require!=="undefined"?require:q)[U]}):Q)(function(Q){if(typeof require!=="undefined")return require.apply(this,arguments);throw Error('Dynamic require of "'+Q+'" is not supported')});var O0={};y0(O0,{resolveObject:()=>$0,resolve:()=>H0,parse:()=>a,format:()=>j0,default:()=>o0,Url:()=>u,URLSearchParams:()=>k0,URL:()=>L0});function V0(Q){return typeof Q=="string"}function B0(Q){return typeof Q=="object"&&Q!==null}function Q0(Q){return Q===null}function l0(Q){return Q==null}function u(){this.protocol=null,this.slashes=null,this.auth=null,this.host=null,this.port=null,this.hostname=null,this.hash=null,this.search=null,this.query=null,this.pathname=null,this.path=null,this.href=null}function a(Q,q,U){if(Q&&B0(Q)&&Q instanceof u)return Q;var X=new u;return X.parse(Q,q,U),X}function j0(Q){return V0(Q)&&(Q=a(Q)),Q instanceof u?Q.format():u.prototype.format.call(Q)}function H0(Q,q){return a(Q,!1,!0).resolve(q)}function $0(Q,q){return Q?a(Q,!1,!0).resolveObject(q):q}var L0,k0,d0,f0,s0,u0,c0,T0,W0,E0,m0=255,N0,r0,n0,K0,t,G0,o0;var I0=v0(()=>{({URL:L0,URLSearchParams:k0}=globalThis),d0=/^([a-z0-9.+-]+:)/i,f0=/:[0-9]*$/,s0=/^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,u0=["<",">",'"',"`"," ","\r",`
`,"	"],c0=["{","}","|","\\","^","`"].concat(u0),T0=["'"].concat(c0),W0=["%","/","?",";","#"].concat(T0),E0=["/","?","#"],N0=/^[+a-z0-9A-Z_-]{0,63}$/,r0=/^([+a-z0-9A-Z_-]{0,63})(.*)$/,n0={javascript:!0,"javascript:":!0},K0={javascript:!0,"javascript:":!0},t={http:!0,https:!0,ftp:!0,gopher:!0,file:!0,"http:":!0,"https:":!0,"ftp:":!0,"gopher:":!0,"file:":!0},G0={parse(Q){var q=decodeURIComponent;return(Q+"").replace(/\+/g," ").split("&").filter(Boolean).reduce(function(U,X,Y){var Z=X.split("="),J=q(Z[0]||""),R=q(Z[1]||""),K=U[J];return U[J]=K===void 0?R:[].concat(K,R),U},{})},stringify(Q){var q=encodeURIComponent;return Object.keys(Q||{}).reduce(function(U,X){return[].concat(Q[X]).forEach(function(Y){U.push(q(X)+"="+q(Y))}),U},[]).join("&").replace(/\s/g,"+")}};u.prototype.parse=function(Q,q,U){if(!V0(Q))throw new TypeError("Parameter 'url' must be a string, not "+typeof Q);var X=Q.indexOf("?"),Y=X!==-1&&X<Q.indexOf("#")?"?":"#",Z=Q.split(Y),J=/\\/g;Z[0]=Z[0].replace(J,"/"),Q=Z.join(Y);var R=Q;if(R=R.trim(),!U&&Q.split("#").length===1){var K=s0.exec(R);if(K)return this.path=R,this.href=R,this.pathname=K[1],K[2]?(this.search=K[2],q?this.query=G0.parse(this.search.substr(1)):this.query=this.search.substr(1)):q&&(this.search="",this.query={}),this}var T=d0.exec(R);if(T){T=T[0];var G=T.toLowerCase();this.protocol=G,R=R.substr(T.length)}if(U||T||R.match(/^\/\/[^@\/]+@[^@\/]+/)){var E=R.substr(0,2)==="//";E&&!(T&&K0[T])&&(R=R.substr(2),this.slashes=!0)}if(!K0[T]&&(E||T&&!t[T])){for(var W=-1,V=0;V<E0.length;V++){var w=R.indexOf(E0[V]);w!==-1&&(W===-1||w<W)&&(W=w)}var F,C;W===-1?C=R.lastIndexOf("@"):C=R.lastIndexOf("@",W),C!==-1&&(F=R.slice(0,C),R=R.slice(C+1),this.auth=decodeURIComponent(F)),W=-1;for(var V=0;V<W0.length;V++){var w=R.indexOf(W0[V]);w!==-1&&(W===-1||w<W)&&(W=w)}W===-1&&(W=R.length),this.host=R.slice(0,W),R=R.slice(W),this.parseHost(),this.hostname=this.hostname||"";var S=this.hostname[0]==="["&&this.hostname[this.hostname.length-1]==="]";if(!S)for(var L=this.hostname.split(/\./),V=0,k=L.length;V<k;V++){var I=L[V];if(!!I&&!I.match(N0)){for(var M="",A=0,b=I.length;A<b;A++)I.charCodeAt(A)>127?M+="x":M+=I[A];if(!M.match(N0)){var h=L.slice(0,V),x=L.slice(V+1),r=I.match(r0);r&&(h.push(r[1]),x.unshift(r[2])),x.length&&(R="/"+x.join(".")+R),this.hostname=h.join(".");break}}}this.hostname.length>m0?this.hostname="":this.hostname=this.hostname.toLowerCase(),S||(this.hostname=new L0(`https://${this.hostname}`).hostname);var N=this.port?":"+this.port:"",j=this.hostname||"";this.host=j+N,this.href+=this.host,S&&(this.hostname=this.hostname.substr(1,this.hostname.length-2),R[0]!=="/"&&(R="/"+R))}if(!n0[G])for(var V=0,k=T0.length;V<k;V++){var B=T0[V];if(R.indexOf(B)!==-1){var H=encodeURIComponent(B);H===B&&(H=escape(B)),R=R.split(B).join(H)}}var $=R.indexOf("#");$!==-1&&(this.hash=R.substr($),R=R.slice(0,$));var O=R.indexOf("?");if(O!==-1?(this.search=R.substr(O),this.query=R.substr(O+1),q&&(this.query=G0.parse(this.query)),R=R.slice(0,O)):q&&(this.search="",this.query={}),R&&(this.pathname=R),t[G]&&this.hostname&&!this.pathname&&(this.pathname="/"),this.pathname||this.search){var N=this.pathname||"",z=this.search||"";this.path=N+z}return this.href=this.format(),this};u.prototype.format=function(){var Q=this.auth||"";Q&&(Q=encodeURIComponent(Q),Q=Q.replace(/%3A/i,":"),Q+="@");var q=this.protocol||"",U=this.pathname||"",X=this.hash||"",Y=!1,Z="";this.host?Y=Q+this.host:this.hostname&&(Y=Q+(this.hostname.indexOf(":")===-1?this.hostname:"["+this.hostname+"]"),this.port&&(Y+=":"+this.port)),this.query&&B0(this.query)&&Object.keys(this.query).length&&(Z=G0.stringify(this.query));var J=this.search||Z&&"?"+Z||"";return q&&q.substr(-1)!==":"&&(q+=":"),this.slashes||(!q||t[q])&&Y!==!1?(Y="//"+(Y||""),U&&U.charAt(0)!=="/"&&(U="/"+U)):Y||(Y=""),X&&X.charAt(0)!=="#"&&(X="#"+X),J&&J.charAt(0)!=="?"&&(J="?"+J),U=U.replace(/[?#]/g,function(R){return encodeURIComponent(R)}),J=J.replace("#","%23"),q+Y+U+J+X};u.prototype.resolve=function(Q){return this.resolveObject(a(Q,!1,!0)).format()};u.prototype.resolveObject=function(Q){if(V0(Q)){var q=new u;q.parse(Q,!1,!0),Q=q}for(var U=new u,X=Object.keys(this),Y=0;Y<X.length;Y++){var Z=X[Y];U[Z]=this[Z]}if(U.hash=Q.hash,Q.href==="")return U.href=U.format(),U;if(Q.slashes&&!Q.protocol){for(var J=Object.keys(Q),R=0;R<J.length;R++){var K=J[R];K!=="protocol"&&(U[K]=Q[K])}return t[U.protocol]&&U.hostname&&!U.pathname&&(U.path=U.pathname="/"),U.href=U.format(),U}if(Q.protocol&&Q.protocol!==U.protocol){if(!t[Q.protocol]){for(var T=Object.keys(Q),G=0;G<T.length;G++){var E=T[G];U[E]=Q[E]}return U.href=U.format(),U}if(U.protocol=Q.protocol,!Q.host&&!K0[Q.protocol]){for(var k=(Q.pathname||"").split("/");k.length&&!(Q.host=k.shift()););Q.host||(Q.host=""),Q.hostname||(Q.hostname=""),k[0]!==""&&k.unshift(""),k.length<2&&k.unshift(""),U.pathname=k.join("/")}else U.pathname=Q.pathname;if(U.search=Q.search,U.query=Q.query,U.host=Q.host||"",U.auth=Q.auth,U.hostname=Q.hostname||Q.host,U.port=Q.port,U.pathname||U.search){var W=U.pathname||"",V=U.search||"";U.path=W+V}return U.slashes=U.slashes||Q.slashes,U.href=U.format(),U}var w=U.pathname&&U.pathname.charAt(0)==="/",F=Q.host||Q.pathname&&Q.pathname.charAt(0)==="/",C=F||w||U.host&&Q.pathname,S=C,L=U.pathname&&U.pathname.split("/")||[],k=Q.pathname&&Q.pathname.split("/")||[],I=U.protocol&&!t[U.protocol];if(I&&(U.hostname="",U.port=null,U.host&&(L[0]===""?L[0]=U.host:L.unshift(U.host)),U.host="",Q.protocol&&(Q.hostname=null,Q.port=null,Q.host&&(k[0]===""?k[0]=Q.host:k.unshift(Q.host)),Q.host=null),C=C&&(k[0]===""||L[0]==="")),F)U.host=Q.host||Q.host===""?Q.host:U.host,U.hostname=Q.hostname||Q.hostname===""?Q.hostname:U.hostname,U.search=Q.search,U.query=Q.query,L=k;else if(k.length)L||(L=[]),L.pop(),L=L.concat(k),U.search=Q.search,U.query=Q.query;else if(!l0(Q.search)){if(I){U.hostname=U.host=L.shift();var M=U.host&&U.host.indexOf("@")>0?U.host.split("@"):!1;M&&(U.auth=M.shift(),U.host=U.hostname=M.shift())}return U.search=Q.search,U.query=Q.query,(!Q0(U.pathname)||!Q0(U.search))&&(U.path=(U.pathname?U.pathname:"")+(U.search?U.search:"")),U.href=U.format(),U}if(!L.length)return U.pathname=null,U.search?U.path="/"+U.search:U.path=null,U.href=U.format(),U;for(var A=L.slice(-1)[0],b=(U.host||Q.host||L.length>1)&&(A==="."||A==="..")||A==="",h=0,x=L.length;x>=0;x--)A=L[x],A==="."?L.splice(x,1):A===".."?(L.splice(x,1),h++):h&&(L.splice(x,1),h--);if(!C&&!S)for(;h--;h)L.unshift("..");C&&L[0]!==""&&(!L[0]||L[0].charAt(0)!=="/")&&L.unshift(""),b&&L.join("/").substr(-1)!=="/"&&L.push("");var r=L[0]===""||L[0]&&L[0].charAt(0)==="/";if(I){U.hostname=U.host=r?"":L.length?L.shift():"";var M=U.host&&U.host.indexOf("@")>0?U.host.split("@"):!1;M&&(U.auth=M.shift(),U.host=U.hostname=M.shift())}return C=C||U.host&&L.length,C&&!r&&L.unshift(""),L.length?U.pathname=L.join("/"):(U.pathname=null,U.path=null),(!Q0(U.pathname)||!Q0(U.search))&&(U.path=(U.pathname?U.pathname:"")+(U.search?U.search:"")),U.auth=Q.auth||U.auth,U.slashes=U.slashes||Q.slashes,U.href=U.format(),U};u.prototype.parseHost=function(){var Q=this.host,q=f0.exec(Q);q&&(q=q[0],q!==":"&&(this.port=q.substr(1)),Q=Q.substr(0,Q.length-q.length)),Q&&(this.hostname=Q)};o0={parse:a,resolve:H0,resolveObject:$0,format:j0,Url:u,URL:L0,URLSearchParams:k0}});function qq(Q,q,U,X){function Y(Z){return Z instanceof U?Z:new U(function(J){J(Z)})}return new(U||(U=Promise))(function(Z,J){function R(G){try{T(X.next(G))}catch(E){J(E)}}function K(G){try{T(X.throw(G))}catch(E){J(E)}}function T(G){G.done?Z(G.value):Y(G.value).then(R,K)}T((X=X.apply(Q,q||[])).next())})}function Uq(Q,q){var U={label:0,sent:function(){if(Z[0]&1)throw Z[1];return Z[1]},trys:[],ops:[]},X,Y,Z,J=Object.create((typeof Iterator==="function"?Iterator:Object).prototype);return J.next=R(0),J.throw=R(1),J.return=R(2),typeof Symbol==="function"&&(J[Symbol.iterator]=function(){return this}),J;function R(T){return function(G){return K([T,G])}}function K(T){if(X)throw new TypeError("Generator is already executing.");while(J&&(J=0,T[0]&&(U=0)),U)try{if(X=1,Y&&(Z=T[0]&2?Y.return:T[0]?Y.throw||((Z=Y.return)&&Z.call(Y),0):Y.next)&&!(Z=Z.call(Y,T[1])).done)return Z;if(Y=0,Z)T=[T[0]&2,Z.value];switch(T[0]){case 0:case 1:Z=T;break;case 4:return U.label++,{value:T[1],done:!1};case 5:U.label++,Y=T[1],T=[0];continue;case 7:T=U.ops.pop(),U.trys.pop();continue;default:if((Z=U.trys,!(Z=Z.length>0&&Z[Z.length-1]))&&(T[0]===6||T[0]===2)){U=0;continue}if(T[0]===3&&(!Z||T[1]>Z[0]&&T[1]<Z[3])){U.label=T[1];break}if(T[0]===6&&U.label<Z[1]){U.label=Z[1],Z=T;break}if(Z&&U.label<Z[2]){U.label=Z[2],U.ops.push(T);break}if(Z[2])U.ops.pop();U.trys.pop();continue}T=q.call(Q,U)}catch(G){T=[6,G],Y=0}finally{X=Z=0}if(T[0]&5)throw T[1];return{value:T[0]?T[1]:void 0,done:!0}}}function _0(Q){if(Q instanceof Uint8Array)return Q;if(typeof Q==="string")return Rq(Q);if(ArrayBuffer.isView(Q))return new Uint8Array(Q.buffer,Q.byteOffset,Q.byteLength/Uint8Array.BYTES_PER_ELEMENT);return new Uint8Array(Q)}function Tq(Q){if(typeof Q==="string")return Q.length===0;return Q.byteLength===0}function Gq(Q){var q=_0(Q);if(q.byteLength>c){var U=new X0;U.update(q),q=U.digest()}var X=new Uint8Array(c);return X.set(q),X}var C0=(Q,q,U)=>{if(!q.has(Q))throw TypeError("Cannot "+U)},M0=(Q,q,U)=>{return C0(Q,q,"read from private field"),U?U.call(Q):q.get(Q)},A0=(Q,q,U)=>{if(q.has(Q))throw TypeError("Cannot add the same private member more than once");q instanceof WeakSet?q.add(Q):q.set(Q,U)},w0=(Q,q,U,X)=>{return C0(Q,q,"write to private field"),X?X.call(Q,U):q.set(Q,U),U},i0=async(Q,q=Q.replace(/c?js$/,"data"),U=Q.replace(/c?js$/,"wasm"))=>{var X,Y;let Z,J,R;const K=/var (.+) = \(/;if(typeof window==="object"){let G=await(await fetch(Q)).text();G=`${G}
export default ${(X=G.match(K))==null?void 0:X[1]};
`,Z=(await import(URL.createObjectURL(new Blob([G],{type:"text/javascript"})))).default,J=await(await fetch(q)).arrayBuffer(),R=new Uint8Array(await(await fetch(U)).arrayBuffer())}else{const{promises:G}=await import("fs"),{pathToFileURL:E}=await Promise.resolve().then(() => (I0(),O0));let W=await G.readFile(Q,{encoding:"utf-8"});W=`
import process from "process";
import * as path from "path";
import { createRequire } from "module";
import { fileURLToPath } from "url";

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const __filename = fileURLToPath(import.meta.url);
const require = createRequire(import.meta.url);

${W}

export default ${(Y=W.match(K))==null?void 0:Y[1]};
`;const V=Q.replace(/c?js$/,"mjs");await G.writeFile(V,W),Z=(await import(E(V).href)).default,await G.unlink(V),J=(await G.readFile(q)).buffer,R=(await G.readFile(U)).buffer}return await Z({wasmBinary:R,getPreloadedPackage:(G,E)=>{if(G==="libfaust-wasm.data")return J;return new ArrayBuffer(0)}})},z0=i0,t0=(Q,q,U=!0)=>{const{registerProcessor:X,AudioWorkletProcessor:Y,sampleRate:Z}=globalThis,{FaustBaseWebAudioDsp:J,FaustWasmInstantiator:R}=Q,{processorName:K,dspName:T,dspMeta:G,effectMeta:E,poly:W}=q,V=(L)=>{const k=["/gate","/freq","/gain","/key","/vel","/velocity"],I="address"in L&&!!k.find((M)=>L.address.endsWith(M));if(W&&I)return null;if(L.type==="vslider"||L.type==="hslider"||L.type==="nentry")return{name:L.address,defaultValue:L.init||0,minValue:L.min||0,maxValue:L.max||0};else if(L.type==="button"||L.type==="checkbox")return{name:L.address,defaultValue:L.init||0,minValue:0,maxValue:1};return null};class w extends Y{constructor(L){super(L);this.paramValuesCache={},this.port.onmessage=(A)=>this.handleMessageAux(A);const{parameterDescriptors:k}=this.constructor;k.forEach((A)=>{this.paramValuesCache[A.name]=A.defaultValue||0});const{moduleId:I,instanceId:M}=L.processorOptions;if(!I||!M)return;this.wamInfo={moduleId:I,instanceId:M}}static get parameterDescriptors(){const L=[],k=(I)=>{const M=V(I);if(M)L.push(M)};if(J.parseUI(G.ui,k),E)J.parseUI(E.ui,k);return L}setupWamEventHandler(){var L;if(!this.wamInfo)return;const{moduleId:k,instanceId:I}=this.wamInfo,{webAudioModules:M}=globalThis,A=M.getModuleScope(k),b=(L=A==null?void 0:A.paramMgrProcessors)==null?void 0:L[I];if(!b)return;if(b.handleEvent)return;b.handleEvent=(h)=>{if(h.type==="wam-midi")this.midiMessage(h.data.bytes)}}process(L,k,I){for(let M in I){const[A]=I[M];if(A!==this.paramValuesCache[M])this.fDSPCode.setParamValue(M,A),this.paramValuesCache[M]=A}return this.fDSPCode.compute(L[0],k[0])}handleMessageAux(L){const k=L.data;switch(k.type){case"acc":{this.propagateAcc(k.data,k.invert);break}case"gyr":{this.propagateGyr(k.data);break}case"midi":{this.midiMessage(k.data);break}case"ctrlChange":{this.ctrlChange(k.data[0],k.data[1],k.data[2]);break}case"pitchWheel":{this.pitchWheel(k.data[0],k.data[1]);break}case"param":{this.setParamValue(k.data.path,k.data.value);break}case"setPlotHandler":{if(k.data)this.fDSPCode.setPlotHandler((I,M,A)=>this.port.postMessage({type:"plot",value:I,index:M,events:A}));else this.fDSPCode.setPlotHandler(null);break}case"setupWamEventHandler":{this.setupWamEventHandler();break}case"start":{this.fDSPCode.start();break}case"stop":{this.fDSPCode.stop();break}case"destroy":{this.port.close(),this.fDSPCode.destroy();break}default:break}}setParamValue(L,k){this.fDSPCode.setParamValue(L,k),this.paramValuesCache[L]=k}midiMessage(L){this.fDSPCode.midiMessage(L)}ctrlChange(L,k,I){this.fDSPCode.ctrlChange(L,k,I)}pitchWheel(L,k){this.fDSPCode.pitchWheel(L,k)}propagateAcc(L,k=!1){this.fDSPCode.propagateAcc(L,k)}propagateGyr(L){this.fDSPCode.propagateGyr(L)}}class F extends w{constructor(L){super(L);const{FaustMonoWebAudioDsp:k}=Q,{factory:I,sampleSize:M}=L.processorOptions,A=R.createSyncMonoDSPInstance(I);this.fDSPCode=new k(A,Z,M,128,I.soundfiles),this.fDSPCode.setOutputParamHandler((b,h)=>this.port.postMessage({path:b,value:h,type:"param"})),this.fDSPCode.start()}}class C extends w{constructor(L){super(L);this.handleMessageAux=(N)=>{const j=N.data;switch(j.type){case"keyOn":this.keyOn(j.data[0],j.data[1],j.data[2]);break;case"keyOff":this.keyOff(j.data[0],j.data[1],j.data[2]);break;default:super.handleMessageAux(N);break}};const{FaustPolyWebAudioDsp:k}=Q,{voiceFactory:I,mixerModule:M,voices:A,effectFactory:b,sampleSize:h}=L.processorOptions,x=R.createSyncPolyDSPInstance(I,M,A,b),r={...b==null?void 0:b.soundfiles,...I.soundfiles};this.fDSPCode=new k(x,Z,h,128,r),this.port.onmessage=(N)=>this.handleMessageAux(N),this.fDSPCode.setOutputParamHandler((N,j)=>this.port.postMessage({path:N,value:j,type:"param"})),this.fDSPCode.start()}midiMessage(L){const k=L[0]>>4,I=L[0]&15,M=L[1],A=L[2];if(k===8||k===9&&A===0)this.keyOff(I,M,A);else if(k===9)this.keyOn(I,M,A);else super.midiMessage(L)}keyOn(L,k,I){this.fDSPCode.keyOn(L,k,I)}keyOff(L,k,I){this.fDSPCode.keyOff(L,k,I)}allNotesOff(L){this.fDSPCode.allNotesOff(L)}}const S=W?C:F;if(U)try{X(K||T||(W?"mydsp_poly":"mydsp"),S)}catch(L){console.warn(L)}return W?C:F},J0=t0,a0=(Q,q,U=!0)=>{const{registerProcessor:X,AudioWorkletProcessor:Y,sampleRate:Z}=globalThis,{FaustBaseWebAudioDsp:J,FaustWasmInstantiator:R,FaustMonoWebAudioDsp:K,FFTUtils:T}=Q,{processorName:G,dspName:E,dspMeta:W,fftOptions:V}=q,{windowFunctions:w,getFFT:F,fftToSignal:C,signalToFFT:S,signalToNoFFT:L}=T,k=(N,j)=>Math.abs(j)<1?Math.ceil(N*(1/j))/(1/j):Math.ceil(N/j)*j,I=(N,j)=>(N%j+j)%j,M=(N,j)=>{for(let B=0;B<N.length;B++)N[B]*=j(B,N.length)},A=["/fftSize","/fftHopSize","/fftOverlap","/windowFunction","/noIFFT"],b=(N,j,B=0,H=0)=>{const $=N.length,O=j.length,z=Math.min($,O);let y=0,D=I(B,$)||0,_=I(H,O)||0;while(y<z){const v=Math.min(z-y,$-D,O-_),i=_+v;if(_===0&&i===O)N.set(j,D);else N.set(j.subarray(_,i),D);D=(D+v)%$,_=i%O,y+=v}return D},h=(N)=>{if("address"in N&&!!A.find((B)=>N.address.endsWith(B)))return null;if(N.type==="vslider"||N.type==="hslider"||N.type==="nentry")return{name:N.address,defaultValue:N.init||0,minValue:N.min||0,maxValue:N.max||0};else if(N.type==="button"||N.type==="checkbox")return{name:N.address,defaultValue:N.init||0,minValue:0,maxValue:1};return null};class x extends Y{constructor(N){super(N);this.paramValuesCache={},this.destroyed=!1,this.$inputWrite=0,this.$inputRead=0,this.$outputWrite=0,this.$outputRead=0,this.noIFFT=!1,this.fftInput=[],this.fftOutput=[],this.fftOverlap=0,this.fftHopSize=0,this.fftSize=0,this.fftBufferSize=0,this.fPlotHandler=null,this.fCachedEvents=[],this.fBufferNum=0,this.soundfiles={},this.windowFunction=null,this.port.onmessage=(z)=>this.handleMessageAux(z);const{parameterDescriptors:j}=this.constructor;j.forEach((z)=>{this.paramValuesCache[z.name]=z.defaultValue||0});const{factory:B,sampleSize:H}=N.processorOptions;this.dspInstance=R.createSyncMonoDSPInstance(B),this.sampleSize=H,this.soundfiles=B.soundfiles,this.initFFT();const{moduleId:$,instanceId:O}=N.processorOptions;if(!$||!O)return;this.wamInfo={moduleId:$,instanceId:O}}get fftProcessorBufferSize(){return this.fftSize/2+1}async initFFT(){return this.FFT=await F(),await this.createFFTProcessor(),!0}static get parameterDescriptors(){const N=[],j=(B)=>{const H=h(B);if(H)N.push(H)};return J.parseUI(W.ui,j),[...N,{defaultValue:(V==null?void 0:V.fftSize)||1024,maxValue:4294967296,minValue:2,name:"fftSize"},{defaultValue:(V==null?void 0:V.fftOverlap)||2,maxValue:32,minValue:1,name:"fftOverlap"},{defaultValue:typeof(V==null?void 0:V.defaultWindowFunction)==="number"?V.defaultWindowFunction+1:0,maxValue:(w==null?void 0:w.length)||0,minValue:0,name:"windowFunction"},{defaultValue:+!!(V==null?void 0:V.noIFFT)||0,maxValue:1,minValue:0,name:"noIFFT"}]}setupWamEventHandler(){var N;if(!this.wamInfo)return;const{moduleId:j,instanceId:B}=this.wamInfo,{webAudioModules:H}=globalThis,$=H.getModuleScope(j),O=(N=$==null?void 0:$.paramMgrProcessors)==null?void 0:N[B];if(!O)return;if(O.handleEvent)return;O.handleEvent=(z)=>{if(z.type==="wam-midi")this.midiMessage(z.data.bytes)}}processFFT(){let N=I(this.$inputWrite-this.$inputRead,this.fftBufferSize)||this.fftBufferSize;while(N>=this.fftSize){let j=[];this.fDSPCode.compute((B)=>{for(let H=0;H<Math.min(this.fftInput.length,Math.ceil(B.length/3));H++){const $=this.rfft.forward((O)=>{b(O,this.fftInput[H],0,this.$inputRead);for(let z=0;z<O.length;z++)O[z]*=this.window[z]});C($,B[H*3],B[H*3+1],B[H*3+2])}for(let H=this.fftInput.length*3;H<B.length;H++)if(H%3===2)B[H].forEach(($,O)=>B[H][O]=O);else B[H].fill(0)},(B)=>{j=B}),this.$inputRead+=this.fftHopSize,this.$inputRead%=this.fftBufferSize,N-=this.fftHopSize;for(let B=0;B<this.fftOutput.length;B++){let H;if(this.noIFFT)H=this.noIFFTBuffer,L(j[B*2]||this.fftProcessorZeros,j[B*2+1]||this.fftProcessorZeros,H);else H=this.rfft.inverse((O)=>{S(j[B*2]||this.fftProcessorZeros,j[B*2+1]||this.fftProcessorZeros,O)});for(let O=0;O<H.length;O++)H[O]*=this.window[O];let $;for(let O=0;O<H.length-this.fftHopSize;O++)if($=I(this.$outputWrite+O,this.fftBufferSize),this.fftOutput[B][$]+=H[O],B===0)this.windowSumSquare[$]+=this.noIFFT?this.window[O]:this.window[O]**2;for(let O=H.length-this.fftHopSize;O<H.length;O++)if($=I(this.$outputWrite+O,this.fftBufferSize),this.fftOutput[B][$]=H[O],B===0)this.windowSumSquare[$]=this.noIFFT?this.window[O]:this.window[O]**2}this.$outputWrite+=this.fftHopSize,this.$outputWrite%=this.fftBufferSize}}process(N,j,B){if(this.destroyed)return!1;if(!this.FFT)return!0;const H=N[0],$=j[0],O=(H==null?void 0:H.length)||0,z=($==null?void 0:$.length)||0,y=(H==null?void 0:H.length)?Math.max(...H.map((D)=>D.length))||128:128;if(this.noIFFT=!!B.noIFFT[0],this.resetFFT(~~B.fftSize[0],~~B.fftOverlap[0],~~B.windowFunction[0],O,z,y),!this.fDSPCode)return!0;for(let D in B){if(A.find((v)=>`/${D}`.endsWith(v)))continue;const[_]=B[D];if(_!==this.paramValuesCache[D])this.fDSPCode.setParamValue(D,_),this.paramValuesCache[D]=_}if(H==null?void 0:H.length){let D=0;for(let _=0;_<H.length;_++){const v=this.fftInput[_],i=H[_].length?H[_]:new Float32Array(y);D=b(v,i,this.$inputWrite)}this.$inputWrite=D}else this.$inputWrite+=y,this.$inputWrite%=this.fftBufferSize;this.processFFT();for(let D=0;D<$.length;D++){b($[D],this.fftOutput[D],0,this.$outputRead);let _=0;for(let v=0;v<y;v++)_=this.windowSumSquare[I(this.$outputRead+v,this.fftBufferSize)],$[D][v]/=_<0.00000001?1:_}if(this.$outputRead+=y,this.$outputRead%=this.fftBufferSize,this.fPlotHandler)this.port.postMessage({type:"plot",value:$,index:this.fBufferNum++,events:this.fCachedEvents}),this.fCachedEvents=[];return!0}handleMessageAux(N){var j,B,H;const $=N.data;switch($.type){case"midi":this.midiMessage($.data);break;case"ctrlChange":this.ctrlChange($.data[0],$.data[1],$.data[2]);break;case"pitchWheel":this.pitchWheel($.data[0],$.data[1]);break;case"param":this.setParamValue($.data.path,$.data.value);break;case"setPlotHandler":{if($.data)this.fPlotHandler=(O,z,y)=>{if(y)this.fCachedEvents.push(...y)};else this.fPlotHandler=null;(j=this.fDSPCode)==null||j.setPlotHandler(this.fPlotHandler);break}case"setupWamEventHandler":{this.setupWamEventHandler();break}case"start":{(B=this.fDSPCode)==null||B.start();break}case"stop":{(H=this.fDSPCode)==null||H.stop();break}case"destroy":{this.port.close(),this.destroy();break}default:break}}setParamValue(N,j){var B;(B=this.fDSPCode)==null||B.setParamValue(N,j),this.paramValuesCache[N]=j}midiMessage(N){var j;(j=this.fDSPCode)==null||j.midiMessage(N)}ctrlChange(N,j,B){var H;(H=this.fDSPCode)==null||H.ctrlChange(N,j,B)}pitchWheel(N,j){var B;(B=this.fDSPCode)==null||B.pitchWheel(N,j)}resetFFT(N,j,B,H,$,O){var z,y;const D=~~k(Math.max(2,N||1024),2),_=~~Math.min(D,Math.max(1,j)),v=~~Math.max(1,D/_),i=D-Math.min(v,O);let q0=null;if(B!==0)q0=typeof w==="object"?w[~~B-1]||null:null;const U0=D!==this.fftSize,R0=_!==this.fftOverlap;if(U0||R0){if(this.fftSize=D,this.fftOverlap=_,this.fftHopSize=v,this.$inputWrite=0,this.$inputRead=0,this.$outputWrite=0,this.$outputRead=-i,this.fftBufferSize=Math.max(D*2-this.fftHopSize,O*2),!U0&&this.fftHopSizeParam)(z=this.fDSPCode)==null||z.setParamValue(this.fftHopSizeParam,this.fftHopSize)}if(U0)(y=this.rfft)==null||y.dispose(),this.rfft=new this.FFT(D),this.noIFFTBuffer=new Float32Array(this.fftSize),this.createFFTProcessor();if(U0||R0||q0!==this.windowFunction){if(this.windowFunction=q0,this.window=new Float32Array(D),this.window.fill(1),q0)M(this.window,q0);this.windowSumSquare=new Float32Array(this.fftBufferSize)}if(this.fftInput.length>H)this.fftInput.splice(H);if(this.fftOutput.length>$)this.fftOutput.splice($);if(U0||R0){for(let p=0;p<H;p++)this.fftInput[p]=new Float32Array(this.fftBufferSize);for(let p=0;p<$;p++)this.fftOutput[p]=new Float32Array(this.fftBufferSize)}else{if(this.fftInput.length<H)for(let p=this.fftInput.length;p<H;p++)this.fftInput[p]=new Float32Array(this.fftBufferSize);if(this.fftOutput.length<$)for(let p=this.fftOutput.length;p<$;p++)this.fftOutput[p]=new Float32Array(this.fftBufferSize)}}async createFFTProcessor(){var N,j;(N=this.fDSPCode)==null||N.stop(),(j=this.fDSPCode)==null||j.destroy(),this.fDSPCode=new K(this.dspInstance,Z,this.sampleSize,this.fftProcessorBufferSize,this.soundfiles),this.fDSPCode.setOutputParamHandler(($,O)=>this.port.postMessage({path:$,value:O,type:"param"})),this.fDSPCode.setPlotHandler(this.fPlotHandler);const B=this.fDSPCode.getParams();this.fDSPCode.start();for(let $ in this.paramValuesCache){if(A.find((O)=>`/${$}`.endsWith(O)))continue;this.fDSPCode.setParamValue($,this.paramValuesCache[$])}const H=B.find(($)=>$.endsWith("/fftSize"));if(H)this.fDSPCode.setParamValue(H,this.fftSize);if(this.fftHopSizeParam=B.find(($)=>$.endsWith("/fftHopSize")),this.fftHopSizeParam)this.fDSPCode.setParamValue(this.fftHopSizeParam,this.fftHopSize);this.fftProcessorZeros=new Float32Array(this.fftProcessorBufferSize)}destroy(){var N,j,B;(N=this.fDSPCode)==null||N.stop(),(j=this.fDSPCode)==null||j.destroy(),(B=this.rfft)==null||B.dispose(),this.destroyed=!0}}const r=x;if(U)try{X(G||E||"myfftdsp",r)}catch(N){console.warn(N)}return x},e0=a0,c=64,Qq=32,Xq=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),Yq=[1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225],Zq=Math.pow(2,53)-1,X0=function(){function Q(){this.state=Int32Array.from(Yq),this.temp=new Int32Array(64),this.buffer=new Uint8Array(64),this.bufferLength=0,this.bytesHashed=0,this.finished=!1}return Q.prototype.update=function(q){if(this.finished)throw new Error("Attempted to update an already finished hash.");var U=0,X=q.byteLength;if(this.bytesHashed+=X,this.bytesHashed*8>Zq)throw new Error("Cannot hash more than 2^53 - 1 bits");while(X>0)if(this.buffer[this.bufferLength++]=q[U++],X--,this.bufferLength===c)this.hashBuffer(),this.bufferLength=0},Q.prototype.digest=function(){if(!this.finished){var q=this.bytesHashed*8,U=new DataView(this.buffer.buffer,this.buffer.byteOffset,this.buffer.byteLength),X=this.bufferLength;if(U.setUint8(this.bufferLength++,128),X%c>=c-8){for(var Y=this.bufferLength;Y<c;Y++)U.setUint8(Y,0);this.hashBuffer(),this.bufferLength=0}for(var Y=this.bufferLength;Y<c-8;Y++)U.setUint8(Y,0);U.setUint32(c-8,Math.floor(q/4294967296),!0),U.setUint32(c-4,q),this.hashBuffer(),this.finished=!0}var Z=new Uint8Array(Qq);for(var Y=0;Y<8;Y++)Z[Y*4]=this.state[Y]>>>24&255,Z[Y*4+1]=this.state[Y]>>>16&255,Z[Y*4+2]=this.state[Y]>>>8&255,Z[Y*4+3]=this.state[Y]>>>0&255;return Z},Q.prototype.hashBuffer=function(){var q=this,U=q.buffer,X=q.state,Y=X[0],Z=X[1],J=X[2],R=X[3],K=X[4],T=X[5],G=X[6],E=X[7];for(var W=0;W<c;W++){if(W<16)this.temp[W]=(U[W*4]&255)<<24|(U[W*4+1]&255)<<16|(U[W*4+2]&255)<<8|U[W*4+3]&255;else{var V=this.temp[W-2],w=(V>>>17|V<<15)^(V>>>19|V<<13)^V>>>10;V=this.temp[W-15];var F=(V>>>7|V<<25)^(V>>>18|V<<14)^V>>>3;this.temp[W]=(w+this.temp[W-7]|0)+(F+this.temp[W-16]|0)}var C=(((K>>>6|K<<26)^(K>>>11|K<<21)^(K>>>25|K<<7))+(K&T^~K&G)|0)+(E+(Xq[W]+this.temp[W]|0)|0)|0,S=((Y>>>2|Y<<30)^(Y>>>13|Y<<19)^(Y>>>22|Y<<10))+(Y&Z^Y&J^Z&J)|0;E=G,G=T,T=K,K=R+C|0,R=J,J=Z,Z=Y,Y=C+S|0}X[0]+=Y,X[1]+=Z,X[2]+=J,X[3]+=R,X[4]+=K,X[5]+=T,X[6]+=G,X[7]+=E},Q}(),Jq=(Q)=>new TextEncoder().encode(Q),Rq=typeof Buffer!=="undefined"&&Buffer.from?function(Q){return Buffer.from(Q,"utf8")}:Jq,Kq=function(){function Q(q){this.secret=q,this.hash=new X0,this.reset()}return Q.prototype.update=function(q){if(Tq(q)||this.error)return;try{this.hash.update(_0(q))}catch(U){this.error=U}},Q.prototype.digestSync=function(){if(this.error)throw this.error;if(this.outer){if(!this.outer.finished)this.outer.update(this.hash.digest());return this.outer.digest()}return this.hash.digest()},Q.prototype.digest=function(){return qq(this,void 0,void 0,function(){return Uq(this,function(q){return[2,this.digestSync()]})})},Q.prototype.reset=function(){if(this.hash=new X0,this.secret){this.outer=new X0;var q=Gq(this.secret),U=new Uint8Array(c);U.set(q);for(var X=0;X<c;X++)q[X]^=54,U[X]^=92;this.hash.update(q),this.outer.update(U);for(var X=0;X<q.byteLength;X++)q[X]=0}},Q}(),Lq=(Q)=>String.fromCharCode.apply(null,Q),Vq=(Q)=>{const q=new ArrayBuffer(Q.length),U=new Uint8Array(q);for(let X=0,Y=Q.length;X<Y;X++)U[X]=Q.charCodeAt(X);return U},Wq=async(Q)=>{const q=new Kq;return q.update(Q),Array.from(await q.digest()).map((Y)=>Y.toString(16).padStart(2,"0")).join("")},P0=class Q{static serializeDSPFactories(){const q={};return this.gFactories.forEach((U,X)=>{const{code:Y,json:Z,poly:J}=U;q[X]={code:btoa(Lq(Y)),json:JSON.parse(Z),poly:J}}),q}static stringifyDSPFactories(){return JSON.stringify(this.serializeDSPFactories())}static deserializeDSPFactories(q){const U=[];for(let X in q){const Y=q[X],{code:Z,json:J,poly:R}=Y,K=Vq(atob(Z));U.push(WebAssembly.compile(K).then((T)=>this.gFactories.set(X,{shaKey:X,cfactory:0,code:K,module:T,json:JSON.stringify(J),poly:R,soundfiles:{}})))}return Promise.all(U)}static importDSPFactories(q){const U=JSON.parse(q);return this.deserializeDSPFactories(U)}constructor(q){this.fLibFaust=q,this.fErrorMessage=""}intVec2intArray(q){const U=q.size(),X=new Uint8Array(U);for(let Y=0;Y<U;Y++)X[Y]=q.get(Y);return X}async createDSPFactory(q,U,X,Y){if(Q.gFactories.size>10)Q.gFactories.clear();let Z=await Wq(q+U+X+(Y?"poly":"mono"));if(Q.gFactories.has(Z))return Q.gFactories.get(Z)||null;else try{const J=this.fLibFaust.createDSPFactory(q,U,X,!Y),R=this.intVec2intArray(J.data);J.data.delete();const K=await WebAssembly.compile(R),T={shaKey:Z,cfactory:J.cfactory,code:R,module:K,json:J.json,poly:Y,soundfiles:{}};return this.deleteDSPFactory(T),Q.gFactories.set(Z,T),T}catch(J){throw this.fErrorMessage=this.fLibFaust.getErrorAfterException(),this.fLibFaust.cleanupAfterException(),this.fErrorMessage?new Error(this.fErrorMessage):J}}version(){return this.fLibFaust.version()}getErrorMessage(){return this.fErrorMessage}async createMonoDSPFactory(q,U,X){return this.createDSPFactory(q,U,X,!1)}async createPolyDSPFactory(q,U,X){return this.createDSPFactory(q,U,X,!0)}deleteDSPFactory(q){this.fLibFaust.deleteDSPFactory(q.cfactory),q.cfactory=0}expandDSP(q,U){try{return this.fLibFaust.expandDSP("FaustDSP",q,U)}catch(X){throw this.fErrorMessage=this.fLibFaust.getErrorAfterException(),this.fLibFaust.cleanupAfterException(),this.fErrorMessage?new Error(this.fErrorMessage):X}}generateAuxFiles(q,U,X){try{return this.fLibFaust.generateAuxFiles(q,U,X)}catch(Y){throw this.fErrorMessage=this.fLibFaust.getErrorAfterException(),this.fLibFaust.cleanupAfterException(),this.fErrorMessage?new Error(this.fErrorMessage):Y}}deleteAllDSPFactories(){this.fLibFaust.deleteAllDSPFactories()}fs(){return this.fLibFaust.fs()}async getAsyncInternalMixerModule(q=!1){const U=q?"mixer64Buffer":"mixer32Buffer",X=q?"mixer64Module":"mixer32Module";if(this[X])return{mixerBuffer:this[U],mixerModule:this[X]};const Y=q?"/usr/rsrc/mixer64.wasm":"/usr/rsrc/mixer32.wasm",Z=this.fs().readFile(Y,{encoding:"binary"});this[U]=Z;const J=await WebAssembly.compile(Z);return this[X]=J,{mixerBuffer:Z,mixerModule:J}}getSyncInternalMixerModule(q=!1){const U=q?"mixer64Buffer":"mixer32Buffer",X=q?"mixer64Module":"mixer32Module";if(this[X])return{mixerBuffer:this[U],mixerModule:this[X]};const Y=q?"/usr/rsrc/mixer64.wasm":"/usr/rsrc/mixer32.wasm",Z=this.fs().readFile(Y,{encoding:"binary"});this[U]=Z;const J=new WebAssembly.Module(Z);return this[X]=J,{mixerBuffer:Z,mixerModule:J}}};P0.gFactories=new Map;var Eq=P0,g0=Eq,s=class{constructor(Q){this.fExports=Q}compute(Q,q,U,X){this.fExports.compute(Q,q,U,X)}getNumInputs(Q){return this.fExports.getNumInputs(Q)}getNumOutputs(Q){return this.fExports.getNumOutputs(Q)}getParamValue(Q,q){return this.fExports.getParamValue(Q,q)}getSampleRate(Q){return this.fExports.getSampleRate(Q)}init(Q,q){this.fExports.init(Q,q)}instanceClear(Q){this.fExports.instanceClear(Q)}instanceConstants(Q,q){this.fExports.instanceConstants(Q,q)}instanceInit(Q,q){this.fExports.instanceInit(Q,q)}instanceResetUserInterface(Q){this.fExports.instanceResetUserInterface(Q)}setParamValue(Q,q,U){this.fExports.setParamValue(Q,q,U)}},Nq=class{static createWasmImport(Q){return{env:{memory:Q||new WebAssembly.Memory({initial:100}),memoryBase:0,tableBase:0,_abs:Math.abs,_acosf:Math.acos,_asinf:Math.asin,_atanf:Math.atan,_atan2f:Math.atan2,_ceilf:Math.ceil,_cosf:Math.cos,_expf:Math.exp,_floorf:Math.floor,_fmodf:(q,U)=>q%U,_logf:Math.log,_log10f:Math.log10,_max_f:Math.max,_min_f:Math.min,_remainderf:(q,U)=>q-Math.round(q/U)*U,_powf:Math.pow,_roundf:Math.round,_sinf:Math.sin,_sqrtf:Math.sqrt,_tanf:Math.tan,_acoshf:Math.acosh,_asinhf:Math.asinh,_atanhf:Math.atanh,_coshf:Math.cosh,_sinhf:Math.sinh,_tanhf:Math.tanh,_isnanf:Number.isNaN,_isinff:(q)=>!isFinite(q),_copysignf:(q,U)=>Math.sign(q)===Math.sign(U)?q:-q,_acos:Math.acos,_asin:Math.asin,_atan:Math.atan,_atan2:Math.atan2,_ceil:Math.ceil,_cos:Math.cos,_exp:Math.exp,_floor:Math.floor,_fmod:(q,U)=>q%U,_log:Math.log,_log10:Math.log10,_max_:Math.max,_min_:Math.min,_remainder:(q,U)=>q-Math.round(q/U)*U,_pow:Math.pow,_round:Math.round,_sin:Math.sin,_sqrt:Math.sqrt,_tan:Math.tan,_acosh:Math.acosh,_asinh:Math.asinh,_atanh:Math.atanh,_cosh:Math.cosh,_sinh:Math.sinh,_tanh:Math.tanh,_isnan:Number.isNaN,_isinf:(q)=>!isFinite(q),_copysign:(q,U)=>Math.sign(q)===Math.sign(U)?q:-q,table:new WebAssembly.Table({initial:0,element:"anyfunc"})}}}static createWasmMemoryPoly(Q,q,U,X,Y){const Z=Math.max(4,Q),J=q,R=(G)=>{let E=65536;while(E<G)E*=2;return E},K=X?X.size:0;let T=R(K+U.size*Z+(U.inputs+U.outputs*2)*(J+Y*q))/65536;return T=Math.max(2,T),new WebAssembly.Memory({initial:T})}static createWasmMemoryMono(Q,q,U){const X=Q,Y=(q.size+(q.inputs+q.outputs)*(X+U*Q))/65536;return new WebAssembly.Memory({initial:Y*2})}static createMonoDSPInstanceAux(Q,q,U=null){const X=Q.exports,Y=new s(X);return{memory:U?U:Q.exports.memory,api:Y,json:q}}static createMemoryMono(Q){const q=JSON.parse(Q.json),U=q.compile_options.match("-double")?8:4;return this.createWasmMemoryMono(U,q,8192)}static createMemoryPoly(Q,q,U){const X=JSON.parse(q.json),Y=U&&U.json?JSON.parse(U.json):null,Z=X.compile_options.match("-double")?8:4;return this.createWasmMemoryPoly(Q,Z,X,Y,8192)}static createMixerAux(Q,q){const U={imports:{print:console.log},memory:{memory:q}};return new WebAssembly.Instance(Q,U).exports}static async loadDSPFactory(Q,q){const U=await fetch(Q);if(!U.ok)throw new Error(`=> exception raised while running loadDSPFactory, file not found: ${Q}`);try{const X=await U.arrayBuffer(),Y=await WebAssembly.compile(X),J=await(await fetch(q)).text(),T=JSON.parse(J).compile_options.indexOf("wasm-e")!==-1;return{cfactory:0,code:new Uint8Array(X),module:Y,json:J,poly:T}}catch(X){throw X}}static async loadDSPMixer(Q,q){try{let U=null;if(q)U=q.readFile(Q,{encoding:"binary"});else U=await(await fetch(Q)).arrayBuffer();return WebAssembly.compile(U)}catch(U){throw U}}static async createAsyncMonoDSPInstance(Q){if(/"type":\s*"soundfile"/.test(Q.json)){const X=this.createMemoryMono(Q),Y=await WebAssembly.instantiate(Q.module,this.createWasmImport(X));return this.createMonoDSPInstanceAux(Y,Q.json,X)}else{const X=await WebAssembly.instantiate(Q.module,this.createWasmImport());return this.createMonoDSPInstanceAux(X,Q.json)}}static createSyncMonoDSPInstance(Q){if(/"type":\s*"soundfile"/.test(Q.json)){const X=this.createMemoryMono(Q),Y=new WebAssembly.Instance(Q.module,this.createWasmImport(X));return this.createMonoDSPInstanceAux(Y,Q.json,X)}else{const X=new WebAssembly.Instance(Q.module,this.createWasmImport());return this.createMonoDSPInstanceAux(X,Q.json)}}static async createAsyncPolyDSPInstance(Q,q,U,X){const Y=this.createMemoryPoly(U,Q,X),J=(await WebAssembly.instantiate(Q.module,this.createWasmImport(Y))).exports,R=new s(J),K=this.createMixerAux(q,Y);if(X){const G=(await WebAssembly.instantiate(X.module,this.createWasmImport(Y))).exports,E=new s(G);return{memory:Y,voices:U,voiceAPI:R,effectAPI:E,mixerAPI:K,voiceJSON:Q.json,effectJSON:X.json}}else return{memory:Y,voices:U,voiceAPI:R,mixerAPI:K,voiceJSON:Q.json}}static createSyncPolyDSPInstance(Q,q,U,X){const Y=this.createMemoryPoly(U,Q,X),J=new WebAssembly.Instance(Q.module,this.createWasmImport(Y)).exports,R=new s(J),K=this.createMixerAux(q,Y);if(X){const G=new WebAssembly.Instance(X.module,this.createWasmImport(Y)).exports,E=new s(G);return{memory:Y,voices:U,voiceAPI:R,effectAPI:E,mixerAPI:K,voiceJSON:Q.json,effectJSON:X.json}}else return{memory:Y,voices:U,voiceAPI:R,mixerAPI:K,voiceJSON:Q.json}}},l=Nq,d=class Q{static convertToAxis(q){switch(q){case 0:return 0;case 1:return 1;case 2:return 2;default:return console.error("Error: Axis not found value: "+q),0}}static convertToCurve(q){switch(q){case 0:return 0;case 1:return 1;case 2:return 2;case 3:return 3;default:return console.error("Error: Curve not found value: "+q),0}}static get Range(){if(!this._Range)this._Range=class{constructor(q,U){this.fLo=Math.min(q,U),this.fHi=Math.max(q,U)}clip(q){if(q<this.fLo)return this.fLo;if(q>this.fHi)return this.fHi;return q}};return this._Range}static get Interpolator(){if(!this._Interpolator)this._Interpolator=class{constructor(q,U,X,Y){if(this.fRange=new Q.Range(q,U),U!==q)this.fCoef=(Y-X)/(U-q),this.fOffset=X-q*this.fCoef;else this.fCoef=0,this.fOffset=(X+Y)/2}returnMappedValue(q){var U=this.fRange.clip(q);return this.fOffset+U*this.fCoef}getLowHigh(q,U){return{amin:this.fRange.fLo,amax:this.fRange.fHi}}};return this._Interpolator}static get Interpolator3pt(){if(!this._Interpolator3pt)this._Interpolator3pt=class{constructor(q,U,X,Y,Z,J){this.fSegment1=new Q.Interpolator(q,U,Y,Z),this.fSegment2=new Q.Interpolator(U,X,Z,J),this.fMid=U}returnMappedValue(q){return q<this.fMid?this.fSegment1.returnMappedValue(q):this.fSegment2.returnMappedValue(q)}getMappingValues(q,U,X){var Y=this.fSegment1.getLowHigh(q,U),Z=this.fSegment2.getLowHigh(U,X);return{amin:Y.amin,amid:Z.amin,amax:Z.amax}}};return this._Interpolator3pt}static get UpConverter(){if(!this._UpConverter)this._UpConverter=class{constructor(q,U,X,Y,Z,J){this.fActive=!0,this.fA2F=new Q.Interpolator3pt(q,U,X,Y,Z,J),this.fF2A=new Q.Interpolator3pt(Y,Z,J,q,U,X)}uiToFaust(q){return this.fA2F.returnMappedValue(q)}faustToUi(q){return this.fF2A.returnMappedValue(q)}setMappingValues(q,U,X,Y,Z,J){this.fA2F=new Q.Interpolator3pt(q,U,X,Y,Z,J),this.fF2A=new Q.Interpolator3pt(Y,Z,J,q,U,X)}getMappingValues(q,U,X){return this.fA2F.getMappingValues(q,U,X)}setActive(q){this.fActive=q}getActive(){return this.fActive}};return this._UpConverter}static get DownConverter(){if(!this._DownConverter)this._DownConverter=class{constructor(q,U,X,Y,Z,J){this.fActive=!0,this.fA2F=new Q.Interpolator3pt(q,U,X,J,Z,Y),this.fF2A=new Q.Interpolator3pt(Y,Z,J,X,U,q)}uiToFaust(q){return this.fA2F.returnMappedValue(q)}faustToUi(q){return this.fF2A.returnMappedValue(q)}setMappingValues(q,U,X,Y,Z,J){this.fA2F=new Q.Interpolator3pt(q,U,X,J,Z,Y),this.fF2A=new Q.Interpolator3pt(Y,Z,J,X,U,q)}getMappingValues(q,U,X){return this.fA2F.getMappingValues(q,U,X)}setActive(q){this.fActive=q}getActive(){return this.fActive}};return this._DownConverter}static get UpDownConverter(){if(!this._UpDownConverter)this._UpDownConverter=class{constructor(q,U,X,Y,Z,J){this.fActive=!0,this.fA2F=new Q.Interpolator3pt(q,U,X,Y,J,Y),this.fF2A=new Q.Interpolator(Y,J,q,X)}uiToFaust(q){return this.fA2F.returnMappedValue(q)}faustToUi(q){return this.fF2A.returnMappedValue(q)}setMappingValues(q,U,X,Y,Z,J){this.fA2F=new Q.Interpolator3pt(q,U,X,Y,J,Y),this.fF2A=new Q.Interpolator(Y,J,q,X)}getMappingValues(q,U,X){return this.fA2F.getMappingValues(q,U,X)}setActive(q){this.fActive=q}getActive(){return this.fActive}};return this._UpDownConverter}static get DownUpConverter(){if(!this._DownUpConverter)this._DownUpConverter=class{constructor(q,U,X,Y,Z,J){this.fActive=!0,this.fA2F=new Q.Interpolator3pt(q,U,X,J,Y,J),this.fF2A=new Q.Interpolator(Y,J,q,X)}uiToFaust(q){return this.fA2F.returnMappedValue(q)}faustToUi(q){return this.fF2A.returnMappedValue(q)}setMappingValues(q,U,X,Y,Z,J){this.fA2F=new Q.Interpolator3pt(q,U,X,J,Y,J),this.fF2A=new Q.Interpolator(Y,J,q,X)}getMappingValues(q,U,X){return this.fA2F.getMappingValues(q,U,X)}setActive(q){this.fActive=q}getActive(){return this.fActive}};return this._DownUpConverter}static buildHandler(q,U,X,Y,Z,J,R){switch(q){case 0:return new Q.UpConverter(U,X,Y,Z,J,R);case 1:return new Q.DownConverter(U,X,Y,Z,J,R);case 2:return new Q.UpDownConverter(U,X,Y,Z,J,R);case 3:return new Q.DownUpConverter(U,X,Y,Z,J,R);default:return new Q.UpConverter(U,X,Y,Z,J,R)}}},m=class{constructor(Q,q){this.memory=Q,this.allocatedBytes=q}alloc(Q){const q=this.allocatedBytes,U=q+Q,X=this.memory.buffer.byteLength;if(U>X){const Y=Math.ceil((U-X)/65536);console.log(`GROW: ${Y} pages`),this.memory.grow(Y)}return this.allocatedBytes=U,q}getBuffer(){return this.memory.buffer}getInt32Array(){return new Int32Array(this.memory.buffer)}getInt64Array(){return new BigInt64Array(this.memory.buffer)}getFloat32Array(){return new Float32Array(this.memory.buffer)}getFloat64Array(){return new Float64Array(this.memory.buffer)}},f=class Q{static get MAX_SOUNDFILE_PARTS(){return 256}static get MAX_CHAN(){return 64}static get BUFFER_SIZE(){return 1024}static get SAMPLE_RATE(){return 44100}constructor(q,U,X,Y,Z,J){this.fSampleSize=U,this.fIntSize=this.fSampleSize,this.fPtrSize=4,this.fAllocator=q,console.log(`Soundfile constructor: curChan: ${X}, length: ${Y}, maxChan: ${Z}, totalParts: ${J}`),this.fPtr=q.alloc(4*this.fPtrSize),this.fLength=q.alloc(Q.MAX_SOUNDFILE_PARTS*this.fIntSize),this.fSR=q.alloc(Q.MAX_SOUNDFILE_PARTS*this.fIntSize),this.fOffset=q.alloc(Q.MAX_SOUNDFILE_PARTS*this.fIntSize),this.fBuffers=this.allocBuffers(X,Y,Z);const R=this.fAllocator.getInt32Array();R[this.fPtr>>2]=this.fBuffers,R[this.fPtr+this.fPtrSize>>2]=this.fLength,R[this.fPtr+2*this.fPtrSize>>2]=this.fSR,R[this.fPtr+3*this.fPtrSize>>2]=this.fOffset;for(let K=0;K<X;K++){const T=R[(this.fBuffers>>2)+K];console.log(`allocBuffers AFTER: ${K} - ${T}`)}}allocBuffers(q,U,X){const Y=this.fAllocator.alloc(X*this.fPtrSize);console.log(`allocBuffers buffers: ${Y}`);for(let Z=0;Z<q;Z++){const J=this.fAllocator.alloc(U*this.fSampleSize),R=this.fAllocator.getInt32Array();R[(Y>>2)+Z]=J}return Y}shareBuffers(q,U){const X=this.fAllocator.getInt32Array();for(let Y=q;Y<U;Y++)X[(this.fBuffers>>2)+Y]=X[(this.fBuffers>>2)+Y%q]}copyToOut(q,U,X,Y){if(this.fIntSize===4){const Z=this.fAllocator.getInt32Array();Z[(this.fLength>>Math.log2(this.fIntSize))+q]=Y.audioBuffer[0].length,Z[(this.fSR>>Math.log2(this.fIntSize))+q]=Y.sampleRate,Z[(this.fOffset>>Math.log2(this.fIntSize))+q]=X}else{const Z=this.fAllocator.getInt64Array();Z[(this.fLength>>Math.log2(this.fIntSize))+q]=BigInt(Y.audioBuffer[0].length),Z[(this.fSR>>Math.log2(this.fIntSize))+q]=BigInt(Y.sampleRate),Z[(this.fOffset>>Math.log2(this.fIntSize))+q]=BigInt(X)}if(console.log(`copyToOut: part: ${q}, maxChannels: ${U}, offset: ${X}, buffer: ${Y}`),this.fSampleSize===8)this.copyToOutReal64(U,X,Y);else this.copyToOutReal32(U,X,Y)}copyToOutReal32(q,U,X){const Y=this.fAllocator.getInt32Array(),Z=this.fAllocator.getFloat32Array();for(let J=0;J<X.audioBuffer.length;J++){const R=X.audioBuffer[J],K=Y[(this.fBuffers>>2)+J],T=K+U*this.fSampleSize>>Math.log2(this.fSampleSize),G=K+(U+R.length)*this.fSampleSize>>Math.log2(this.fSampleSize);console.log(`copyToOutReal32 begin: ${T}, end: ${G}, delta: ${G-T}`);const E=Z.subarray(K+U*this.fSampleSize>>Math.log2(this.fSampleSize),K+(U+R.length)*this.fSampleSize>>Math.log2(this.fSampleSize));for(let W=0;W<R.length;W++)E[W]=R[W]}}copyToOutReal64(q,U,X){const Y=this.fAllocator.getInt32Array(),Z=this.fAllocator.getFloat64Array();for(let J=0;J<X.audioBuffer.length;J++){const R=X.audioBuffer[J],K=Y[(this.fBuffers>>2)+J],T=K+U*this.fSampleSize>>Math.log2(this.fSampleSize),G=K+(U+R.length)*this.fSampleSize>>Math.log2(this.fSampleSize);console.log(`copyToOutReal64 begin: ${T}, end: ${G}, delta: ${G-T}`);const E=Z.subarray(K+U*this.fSampleSize>>Math.log2(this.fSampleSize),K+(U+R.length)*this.fSampleSize>>Math.log2(this.fSampleSize));for(let W=0;W<R.length;W++)E[W]=R[W]}}emptyFile(q,U){if(this.fIntSize===4){const X=this.fAllocator.getInt32Array();X[(this.fLength>>Math.log2(this.fIntSize))+q]=Q.BUFFER_SIZE,X[(this.fSR>>Math.log2(this.fIntSize))+q]=Q.SAMPLE_RATE,X[(this.fOffset>>Math.log2(this.fIntSize))+q]=U}else{const X=this.fAllocator.getInt64Array();X[(this.fLength>>Math.log2(this.fIntSize))+q]=BigInt(Q.BUFFER_SIZE),X[(this.fSR>>Math.log2(this.fIntSize))+q]=BigInt(Q.SAMPLE_RATE),X[(this.fOffset>>Math.log2(this.fIntSize))+q]=BigInt(U)}return U+Q.BUFFER_SIZE}displayMemory(q="",U=!1){console.log("Soundfile memory: "+q),console.log(`fPtr: ${this.fPtr}`),console.log(`fBuffers: ${this.fBuffers}`),console.log(`fLength: ${this.fLength}`),console.log(`fSR: ${this.fSR}`),console.log(`fOffset: ${this.fOffset}`);const X=this.fAllocator.getInt32Array();if(U)console.log(`HEAP32: ${X}`);console.log(`HEAP32[this.fPtr >> 2]: ${X[this.fPtr>>2]}`),console.log(`HEAP32[(this.fPtr + ptrSize) >> 2]: ${X[this.fPtr+this.fPtrSize>>2]}`),console.log(`HEAP32[(this.fPtr + 2 * ptrSize) >> 2]: ${X[this.fPtr+2*this.fPtrSize>>2]}`),console.log(`HEAP32[(this.fPtr + 3 * ptrSize) >> 2]: ${X[this.fPtr+3*this.fPtrSize>>2]}`)}getPtr(){return this.fPtr}getHEAP32(){return this.fAllocator.getInt32Array()}getHEAPFloat32(){return this.fAllocator.getFloat32Array()}getHEAPFloat64(){return this.fAllocator.getFloat64Array()}},P=class Q{constructor(q,U,X){this.fOutputHandler=null,this.fComputeHandler=null,this.fPlotHandler=null,this.fCachedEvents=[],this.fBufferNum=0,this.fInChannels=[],this.fOutChannels=[],this.fOutputsTimer=5,this.fInputsItems=[],this.fOutputsItems=[],this.fDescriptor=[],this.fSoundfiles=[],this.fSoundfileBuffers={},this.fPitchwheelLabel=[],this.fCtrlLabel=new Array(128).fill(null).map(()=>[]),this.fPathTable={},this.fUICallback=(Y)=>{if(Y.type==="hbargraph"||Y.type==="vbargraph")this.fOutputsItems.push(Y.address),this.fPathTable[Y.address]=Y.index;else if(Y.type==="vslider"||Y.type==="hslider"||Y.type==="button"||Y.type==="checkbox"||Y.type==="nentry"){if(this.fInputsItems.push(Y.address),this.fPathTable[Y.address]=Y.index,this.fDescriptor.push(Y),!Y.meta)return;Y.meta.forEach((Z)=>{const{midi:J,acc:R,gyr:K}=Z;if(J){const T=J.trim();if(T==="pitchwheel"){const G=T.match(/^pitchwheel\s(\d+)/);if(G)this.fPitchwheelLabel.push({path:Y.address,chan:parseInt(G[1]),min:Y.min,max:Y.max});else this.fPitchwheelLabel.push({path:Y.address,chan:0,min:Y.min,max:Y.max})}else{const G=T.match(/^ctrl\s(\d+)\s(\d+)/),E=T.match(/^ctrl\s(\d+)/);if(G)this.fCtrlLabel[parseInt(G[1])].push({path:Y.address,chan:parseInt(G[2]),min:Y.min,max:Y.max});else if(E)this.fCtrlLabel[parseInt(E[1])].push({path:Y.address,chan:0,min:Y.min,max:Y.max})}}if(R){const T=R.trim().split(" ").map(Number);this.setupAccHandler(Y.address,d.convertToAxis(T[0]),d.convertToCurve(T[1]),T[2],T[3],T[4],Y.min,Y.init,Y.max)}if(K){const T=K.trim().split(" ").map(Number);this.setupGyrHandler(Y.address,d.convertToAxis(T[0]),d.convertToCurve(T[1]),T[2],T[3],T[4],Y.min,Y.init,Y.max)}})}else if(Y.type==="soundfile")this.fSoundfiles.push({name:Y.label,url:Y.url,index:Y.index,basePtr:-1})},this.fProcessing=!1,this.fDestroyed=!1,this.fFirstCall=!0,this.fBufferSize=U,this.fPtrSize=q,this.fSampleSize=q,this.fSoundfileBuffers=X,this.fAcc={x:[],y:[],z:[]},this.fGyr={x:[],y:[],z:[]}}static remap(q,U,X,Y,Z){return(q-U)/(X-U)*(Z-Y)+Y}static parseUI(q,U){q.forEach((X)=>this.parseGroup(X,U))}static parseGroup(q,U){if(q.items)this.parseItems(q.items,U)}static parseItems(q,U){q.forEach((X)=>this.parseItem(X,U))}static parseItem(q,U){if(q.type==="vgroup"||q.type==="hgroup"||q.type==="tgroup")this.parseItems(q.items,U);else U(q)}static splitSoundfileNames(q){return q.replace(/^\{|\}$/g,"").split(";").map((X)=>X.length<=2?"":X.substring(1,X.length-1))}get hasAccInput(){return this.fAcc.x.length+this.fAcc.y.length+this.fAcc.z.length>0}propagateAcc(q,U=!1){const{x:X,y:Y,z:Z}=q;if(U){if(X!==null)this.fAcc.x.forEach((J)=>J(-X));if(Y!==null)this.fAcc.y.forEach((J)=>J(-Y));if(Z!==null)this.fAcc.z.forEach((J)=>J(-Z))}else{if(X!==null)this.fAcc.x.forEach((J)=>J(X));if(Y!==null)this.fAcc.y.forEach((J)=>J(Y));if(Z!==null)this.fAcc.z.forEach((J)=>J(Z))}}get hasGyrInput(){return this.fGyr.x.length+this.fGyr.y.length+this.fGyr.z.length>0}propagateGyr(q){const{alpha:U,beta:X,gamma:Y}=q;if(U!==null)this.fGyr.x.forEach((Z)=>Z(U));if(X!==null)this.fGyr.y.forEach((Z)=>Z(X));if(Y!==null)this.fGyr.z.forEach((Z)=>Z(Y))}setupAccHandler(q,U,X,Y,Z,J,R,K,T){const G=d.buildHandler(X,Y,Z,J,R,K,T);switch(U){case 0:this.fAcc.x.push((E)=>this.setParamValue(q,G.uiToFaust(E)));break;case 1:this.fAcc.y.push((E)=>this.setParamValue(q,G.uiToFaust(E)));break;case 2:this.fAcc.z.push((E)=>this.setParamValue(q,G.uiToFaust(E)));break}}setupGyrHandler(q,U,X,Y,Z,J,R,K,T){const G=d.buildHandler(X,Y,Z,J,R,K,T);switch(U){case 0:this.fGyr.x.push((E)=>this.setParamValue(q,G.uiToFaust(E)));break;case 1:this.fGyr.y.push((E)=>this.setParamValue(q,G.uiToFaust(E)));break;case 2:this.fGyr.z.push((E)=>this.setParamValue(q,G.uiToFaust(E)));break}}static extractUrlsFromMeta(q){const U=q.meta.find((X)=>X.soundfiles!==void 0);if(U)return U.soundfiles.split(";").filter((X)=>X!=="");else return[]}loadSoundfile(q,U,X,Y){console.log(`Soundfile ${X} paths: ${Y}`);const Z=Q.splitSoundfileNames(Y),J=this.fSoundfiles.find((R)=>R.url===Y);if(!J)throw new Error(`Soundfile with ${Y} cannot be found !}`);if(J.basePtr!==-1){const R=q.getInt32Array();console.log(`Soundfile CACHE ${Y}} : ${X} loaded at ${J.basePtr} in wasm memory with index ${J.index}`),R[U+J.index>>2]=J.basePtr}else{const R=this.createSoundfile(q,Z,this.fSoundfileBuffers);if(R){const K=R.getHEAP32();J.basePtr=R.getPtr(),console.log(`Soundfile ${X} loaded at ${J.basePtr} in wasm memory with index ${J.index}`),K[U+J.index>>2]=J.basePtr}else console.log(`Soundfile ${X} for ${Y} cannot be created !}`)}}createSoundfile(q,U,X,Y=f.MAX_CHAN){let Z=1,J=0;for(let T of U){let G=0,E=0;const W=X[T];if(W)G=W.audioBuffer.length,E=W.audioBuffer[0].length;else E=f.BUFFER_SIZE,G=1;Z=Math.max(Z,G),J+=E}J+=(f.MAX_SOUNDFILE_PARTS-U.length)*f.BUFFER_SIZE;const R=new f(q,this.fSampleSize,Z,J,Y,U.length);let K=0;for(let T=0;T<U.length;T++){const G=U[T],E=X[G];if(E)R.copyToOut(T,Y,K,E),K+=E.audioBuffer[0].length;else K=R.emptyFile(T,K)}for(let T=U.length;T<f.MAX_SOUNDFILE_PARTS;T++)K=R.emptyFile(T,K);return R.shareBuffers(Z,Y),R}initSoundfileMemory(q,U){for(let{name:X,url:Y}of this.fSoundfiles)this.loadSoundfile(q,U,X,Y)}updateOutputs(){if(this.fOutputsItems.length>0&&this.fOutputHandler&&this.fOutputsTimer--===0)this.fOutputsTimer=5,this.fOutputsItems.forEach((q)=>{var U;return(U=this.fOutputHandler)==null?void 0:U.call(this,q,this.getParamValue(q))})}metadata(q){if(this.fJSONDsp.meta)this.fJSONDsp.meta.forEach((U)=>q(Object.keys(U)[0],U[Object.keys(U)[0]]))}compute(q,U){return!1}setOutputParamHandler(q){this.fOutputHandler=q}getOutputParamHandler(){return this.fOutputHandler}setComputeHandler(q){this.fComputeHandler=q}getComputeHandler(){return this.fComputeHandler}setPlotHandler(q){this.fPlotHandler=q}getPlotHandler(){return this.fPlotHandler}getNumInputs(){return-1}getNumOutputs(){return-1}midiMessage(q){if(this.fPlotHandler)this.fCachedEvents.push({data:q,type:"midi"});const U=q[0]>>4,X=q[0]&15,Y=q[1],Z=q[2];if(U===11)return this.ctrlChange(X,Y,Z);if(U===14)return this.pitchWheel(X,Z*128+Y)}ctrlChange(q,U,X){if(this.fPlotHandler)this.fCachedEvents.push({type:"ctrlChange",data:[q,U,X]});if(this.fCtrlLabel[U].length)this.fCtrlLabel[U].forEach((Y)=>{const{path:Z,chan:J}=Y;if(J===0||q===J-1){if(this.setParamValue(Z,Q.remap(X,0,127,Y.min,Y.max)),this.fOutputHandler)this.fOutputHandler(Z,this.getParamValue(Z))}})}pitchWheel(q,U){if(this.fPlotHandler)this.fCachedEvents.push({type:"pitchWheel",data:[q,U]});this.fPitchwheelLabel.forEach((X)=>{const{path:Y,chan:Z}=X;if(Z===0||q===Z-1){if(this.setParamValue(Y,Q.remap(U,0,16383,X.min,X.max)),this.fOutputHandler)this.fOutputHandler(Y,this.getParamValue(Y))}})}setParamValue(q,U){}getParamValue(q){return 0}getParams(){return this.fInputsItems}getMeta(){return this.fJSONDsp}getJSON(){return JSON.stringify(this.getMeta())}getUI(){return this.fJSONDsp.ui}getDescriptors(){return this.fDescriptor}hasSoundfiles(){return this.fSoundfiles.length>0}start(){this.fProcessing=!0}stop(){this.fProcessing=!1}destroy(){this.fDestroyed=!0,this.fOutputHandler=null,this.fComputeHandler=null,this.fPlotHandler=null}},n=class extends P{constructor(Q,q,U,X,Y){super(U,X,Y);if(this.fInstance=Q,console.log(`sampleSize: ${U} bufferSize: ${X}`),this.fJSONDsp=JSON.parse(this.fInstance.json),P.parseUI(this.fJSONDsp.ui,this.fUICallback),this.fEndMemory=this.initMemory(),this.fInstance.api.init(this.fDSP,q),this.fSoundfiles.length>0){const Z=new m(this.fInstance.memory,this.fEndMemory);this.initSoundfileMemory(Z,this.fDSP)}}initMemory(){this.fDSP=0;const Q=this.fJSONDsp.size;this.fAudioInputs=Q,this.fAudioOutputs=this.fAudioInputs+this.getNumInputs()*this.fPtrSize;const q=this.fAudioOutputs+this.getNumOutputs()*this.fPtrSize,U=q+this.getNumInputs()*this.fBufferSize*this.fSampleSize,X=U+this.getNumOutputs()*this.fBufferSize*this.fSampleSize,Y=this.fInstance.memory.buffer,Z=new Int32Array(Y),J=this.fSampleSize===4?new Float32Array(Y):new Float64Array(Y);if(this.getNumInputs()>0){for(let K=0;K<this.getNumInputs();K++)Z[(this.fAudioInputs>>2)+K]=q+this.fBufferSize*this.fSampleSize*K;const R=Z.subarray(this.fAudioInputs>>2,this.fAudioInputs+this.getNumInputs()*this.fPtrSize>>2);for(let K=0;K<this.getNumInputs();K++)this.fInChannels[K]=J.subarray(R[K]>>Math.log2(this.fSampleSize),R[K]+this.fBufferSize*this.fSampleSize>>Math.log2(this.fSampleSize))}if(this.getNumOutputs()>0){for(let K=0;K<this.getNumOutputs();K++)Z[(this.fAudioOutputs>>2)+K]=U+this.fBufferSize*this.fSampleSize*K;const R=Z.subarray(this.fAudioOutputs>>2,this.fAudioOutputs+this.getNumOutputs()*this.fPtrSize>>2);for(let K=0;K<this.getNumOutputs();K++)this.fOutChannels[K]=J.subarray(R[K]>>Math.log2(this.fSampleSize),R[K]+this.fBufferSize*this.fSampleSize>>Math.log2(this.fSampleSize))}return X}toString(){return`============== Mono Memory layout ==============
        this.fBufferSize: ${this.fBufferSize}
        this.fJSONDsp.size: ${this.fJSONDsp.size}
        this.fAudioInputs: ${this.fAudioInputs}
        this.fAudioOutputs: ${this.fAudioOutputs}
        this.fDSP: ${this.fDSP}`}compute(Q,q){if(this.fDestroyed)return!1;if(!this.fProcessing)return!0;if(this.fFirstCall)this.initMemory(),this.fFirstCall=!1;if(typeof Q==="function")Q(this.fInChannels);else{if(this.getNumInputs()>0&&(!Q||!Q[0]||Q[0].length===0))return!0;if(this.getNumOutputs()>0&&typeof q!=="function"&&(!q||!q[0]||q[0].length===0))return!0;if(Q!==void 0)for(let X=0;X<Math.min(this.getNumInputs(),Q.length);X++)this.fInChannels[X].set(Q[X])}if(this.fComputeHandler)this.fComputeHandler(this.fBufferSize);this.fInstance.api.compute(this.fDSP,this.fBufferSize,this.fAudioInputs,this.fAudioOutputs),this.updateOutputs();let U=this.fOutChannels;if(typeof q==="function")q(this.fOutChannels);else{for(let X=0;X<Math.min(this.getNumOutputs(),q.length);X++){const Y=this.fOutChannels[X];q[X].set(Y)}U=q}if(this.fPlotHandler)this.fPlotHandler(U,this.fBufferNum++,this.fCachedEvents.length?this.fCachedEvents:void 0),this.fCachedEvents=[];return!0}metadata(Q){super.metadata(Q)}getNumInputs(){return this.fInstance.api.getNumInputs(this.fDSP)}getNumOutputs(){return this.fInstance.api.getNumOutputs(this.fDSP)}setParamValue(Q,q){if(this.fPlotHandler)this.fCachedEvents.push({type:"param",data:{path:Q,value:q}});this.fInstance.api.setParamValue(this.fDSP,this.fPathTable[Q],q)}getParamValue(Q){return this.fInstance.api.getParamValue(this.fDSP,this.fPathTable[Q])}getMeta(){return this.fJSONDsp}getJSON(){return this.fInstance.json}getDescriptors(){return this.fDescriptor}getUI(){return this.fJSONDsp.ui}},g=class Q{constructor(q,U,X,Y,Z){this.fFreqLabel=[],this.fGateLabel=[],this.fGainLabel=[],this.fKeyLabel=[],this.fVelLabel=[],this.fCurNote=Q.kFreeVoice,this.fNextNote=-1,this.fNextVel=-1,this.fDate=0,this.fLevel=0,this.fRelease=0,this.fDSP=q,this.fAPI=U,this.fAPI.init(this.fDSP,Z),this.extractPaths(X,Y)}static get kActiveVoice(){return 0}static get kFreeVoice(){return-1}static get kReleaseVoice(){return-2}static get kLegatoVoice(){return-3}static get kNoVoice(){return-4}static get VOICE_STOP_LEVEL(){return 0.0005}static midiToFreq(q){return 440*2**((q-69)/12)}static normalizeVelocity(q){return q/127}extractPaths(q,U){q.forEach((X)=>{if(X.endsWith("/gate"))this.fGateLabel.push(U[X]);else if(X.endsWith("/freq"))this.fFreqLabel.push(U[X]);else if(X.endsWith("/key"))this.fKeyLabel.push(U[X]);else if(X.endsWith("/gain"))this.fGainLabel.push(U[X]);else if(X.endsWith("/vel")&&X.endsWith("/velocity"))this.fVelLabel.push(U[X])})}keyOn(q,U,X=!1){if(X)this.fNextNote=q,this.fNextVel=U;else this.fFreqLabel.forEach((Y)=>this.fAPI.setParamValue(this.fDSP,Y,Q.midiToFreq(q))),this.fGateLabel.forEach((Y)=>this.fAPI.setParamValue(this.fDSP,Y,1)),this.fGainLabel.forEach((Y)=>this.fAPI.setParamValue(this.fDSP,Y,Q.normalizeVelocity(U))),this.fKeyLabel.forEach((Y)=>this.fAPI.setParamValue(this.fDSP,Y,q)),this.fVelLabel.forEach((Y)=>this.fAPI.setParamValue(this.fDSP,Y,U)),this.fCurNote=q}keyOff(q=!1){if(this.fGateLabel.forEach((U)=>this.fAPI.setParamValue(this.fDSP,U,0)),q)this.fCurNote=Q.kFreeVoice;else this.fRelease=this.fAPI.getSampleRate(this.fDSP)/2,this.fCurNote=Q.kReleaseVoice}computeLegato(q,U,X,Y){let Z=q/2;this.fGateLabel.forEach((J)=>this.fAPI.setParamValue(this.fDSP,J,0)),this.fAPI.compute(this.fDSP,Z,U,X),this.keyOn(this.fNextNote,this.fNextVel),this.fAPI.compute(this.fDSP,Z,U,Y)}compute(q,U,X){this.fAPI.compute(this.fDSP,q,U,X)}setParamValue(q,U){this.fAPI.setParamValue(this.fDSP,q,U)}getParamValue(q){return this.fAPI.getParamValue(this.fDSP,q)}},e=class Q extends P{constructor(q,U,X,Y,Z){super(X,Y,Z);if(this.fInstance=q,console.log(`sampleSize: ${X} bufferSize: ${Y}`),this.fJSONDsp=JSON.parse(this.fInstance.voiceJSON),this.fJSONEffect=this.fInstance.effectAPI&&this.fInstance.effectJSON?JSON.parse(this.fInstance.effectJSON):null,P.parseUI(this.fJSONDsp.ui,this.fUICallback),this.fJSONEffect)P.parseUI(this.fJSONEffect.ui,this.fUICallback);this.fEndMemory=this.initMemory(),this.fVoiceTable=[];for(let J=0;J<this.fInstance.voices;J++)this.fVoiceTable.push(new g(this.fJSONDsp.size*J,this.fInstance.voiceAPI,this.fInputsItems,this.fPathTable,U));if(this.fInstance.effectAPI)this.fInstance.effectAPI.init(this.fEffect,U);if(this.fSoundfiles.length>0){const J=new m(this.fInstance.memory,this.fEndMemory);for(let R=0;R<this.fInstance.voices;R++)this.initSoundfileMemory(J,this.fJSONDsp.size*R)}}initMemory(){this.fEffect=this.fJSONDsp.size*this.fInstance.voices;const q=this.fEffect+(this.fJSONEffect?this.fJSONEffect.size:0);this.fAudioInputs=q,this.fAudioOutputs=this.fAudioInputs+this.getNumInputs()*this.fPtrSize,this.fAudioMixing=this.fAudioOutputs+this.getNumOutputs()*this.fPtrSize,this.fAudioMixingHalf=this.fAudioMixing+this.getNumOutputs()*this.fPtrSize;const U=this.fAudioMixingHalf+this.getNumOutputs()*this.fPtrSize,X=U+this.getNumInputs()*this.fBufferSize*this.fSampleSize,Y=X+this.getNumOutputs()*this.fBufferSize*this.fSampleSize,Z=Y+this.getNumOutputs()*this.fBufferSize*this.fSampleSize,J=this.fInstance.memory.buffer,R=new Int32Array(J),K=this.fSampleSize===4?new Float32Array(J):new Float64Array(J);if(this.getNumInputs()>0){for(let G=0;G<this.getNumInputs();G++)R[(this.fAudioInputs>>2)+G]=U+this.fBufferSize*this.fSampleSize*G;const T=R.subarray(this.fAudioInputs>>2,this.fAudioInputs+this.getNumInputs()*this.fPtrSize>>2);for(let G=0;G<this.getNumInputs();G++)this.fInChannels[G]=K.subarray(T[G]>>Math.log2(this.fSampleSize),T[G]+this.fBufferSize*this.fSampleSize>>Math.log2(this.fSampleSize))}if(this.getNumOutputs()>0){for(let G=0;G<this.getNumOutputs();G++)R[(this.fAudioOutputs>>2)+G]=X+this.fBufferSize*this.fSampleSize*G,R[(this.fAudioMixing>>2)+G]=Y+this.fBufferSize*this.fSampleSize*G,R[(this.fAudioMixingHalf>>2)+G]=Y+this.fBufferSize*this.fSampleSize*G+this.fBufferSize/2*this.fSampleSize;const T=R.subarray(this.fAudioOutputs>>2,this.fAudioOutputs+this.getNumOutputs()*this.fPtrSize>>2);for(let G=0;G<this.getNumOutputs();G++)this.fOutChannels[G]=K.subarray(T[G]>>Math.log2(this.fSampleSize),T[G]+this.fBufferSize*this.fSampleSize>>Math.log2(this.fSampleSize))}return Z}toString(){return`============== Poly Memory layout ==============
        this.fBufferSize: ${this.fBufferSize}
        this.fJSONDsp.size: ${this.fJSONDsp.size}
        this.fAudioInputs: ${this.fAudioInputs}
        this.fAudioOutputs: ${this.fAudioOutputs}
        this.fAudioMixing: ${this.fAudioMixing}
        this.fAudioMixingHalf: ${this.fAudioMixingHalf}`}allocVoice(q,U){return this.fVoiceTable[q].fDate++,this.fVoiceTable[q].fCurNote=U,q}getPlayingVoice(q){let U=g.kNoVoice,X=Number.MAX_VALUE;for(let Y=0;Y<this.fInstance.voices;Y++)if(this.fVoiceTable[Y].fCurNote===q){if(this.fVoiceTable[Y].fDate<X)X=this.fVoiceTable[Y].fDate,U=Y}return U}getFreeVoice(){for(let Z=0;Z<this.fInstance.voices;Z++)if(this.fVoiceTable[Z].fCurNote===g.kFreeVoice)return this.allocVoice(Z,g.kActiveVoice);let{kNoVoice:q,kNoVoice:U}=g,X=Number.MAX_VALUE,Y=Number.MAX_VALUE;for(let Z=0;Z<this.fInstance.voices;Z++)if(this.fVoiceTable[Z].fCurNote===g.kReleaseVoice){if(this.fVoiceTable[Z].fDate<X)X=this.fVoiceTable[Z].fDate,q=Z}else if(this.fVoiceTable[Z].fDate<Y)Y=this.fVoiceTable[Z].fDate,U=Z;if(X!==Number.MAX_VALUE)return console.log(`Steal release voice : voice_date = ${this.fVoiceTable[q].fDate} voice = ${q}`),this.allocVoice(q,g.kLegatoVoice);if(Y!==Number.MAX_VALUE)return console.log(`Steal playing voice : voice_date = ${this.fVoiceTable[U].fDate} voice = ${U}`),this.allocVoice(U,g.kLegatoVoice);return g.kNoVoice}compute(q,U){if(this.fDestroyed)return!1;if(this.fFirstCall)this.initMemory(),this.fFirstCall=!1;if(!this.fProcessing)return!0;if(this.getNumInputs()>0&&(!q||!q[0]||q[0].length===0))return!0;if(this.getNumOutputs()>0&&(!U||!U[0]||U[0].length===0))return!0;if(q!==void 0)for(let X=0;X<Math.min(this.getNumInputs(),q.length);++X)this.fInChannels[X].set(q[X]);if(this.fComputeHandler)this.fComputeHandler(this.fBufferSize);if(this.fInstance.mixerAPI.clearOutput(this.fBufferSize,this.getNumOutputs(),this.fAudioOutputs),this.fVoiceTable.forEach((X)=>{if(X.fCurNote===g.kLegatoVoice)X.computeLegato(this.fBufferSize,this.fAudioInputs,this.fAudioMixing,this.fAudioMixingHalf),this.fInstance.mixerAPI.fadeOut(this.fBufferSize/2,this.getNumOutputs(),this.fAudioMixing),X.fLevel=this.fInstance.mixerAPI.mixCheckVoice(this.fBufferSize,this.getNumOutputs(),this.fAudioMixing,this.fAudioOutputs);else if(X.fCurNote!==g.kFreeVoice){if(X.compute(this.fBufferSize,this.fAudioInputs,this.fAudioMixing),X.fLevel=this.fInstance.mixerAPI.mixCheckVoice(this.fBufferSize,this.getNumOutputs(),this.fAudioMixing,this.fAudioOutputs),X.fRelease-=this.fBufferSize,X.fCurNote==g.kReleaseVoice&&(X.fLevel<g.VOICE_STOP_LEVEL&&X.fRelease<0))X.fCurNote=g.kFreeVoice}}),this.fInstance.effectAPI)this.fInstance.effectAPI.compute(this.fEffect,this.fBufferSize,this.fAudioOutputs,this.fAudioOutputs);if(this.updateOutputs(),U!==void 0){for(let X=0;X<Math.min(this.getNumOutputs(),U.length);X++){const Y=this.fOutChannels[X];U[X].set(Y)}if(this.fPlotHandler)this.fPlotHandler(U,this.fBufferNum++,this.fCachedEvents.length?this.fCachedEvents:void 0),this.fCachedEvents=[]}return!0}getNumInputs(){return this.fInstance.voiceAPI.getNumInputs(0)}getNumOutputs(){return this.fInstance.voiceAPI.getNumOutputs(0)}static findPath(q,U){if(typeof q!=="object")return!1;else if(q.address)return q.address===U;else{for(let X in q)if(Q.findPath(q[X],U))return!0;return!1}}setParamValue(q,U){if(this.fPlotHandler)this.fCachedEvents.push({type:"param",data:{path:q,value:U}});if(this.fJSONEffect&&Q.findPath(this.fJSONEffect.ui,q)&&this.fInstance.effectAPI)this.fInstance.effectAPI.setParamValue(this.fEffect,this.fPathTable[q],U);else this.fVoiceTable.forEach((X)=>X.setParamValue(this.fPathTable[q],U))}getParamValue(q){if(this.fJSONEffect&&Q.findPath(this.fJSONEffect.ui,q)&&this.fInstance.effectAPI)return this.fInstance.effectAPI.getParamValue(this.fEffect,this.fPathTable[q]);else return this.fVoiceTable[0].getParamValue(this.fPathTable[q])}getMeta(){const q=this.fJSONDsp,U=this.fJSONEffect,X={...q};if(U)X.ui=[{type:"tgroup",label:"Sequencer",items:[{type:"vgroup",label:"Instrument",items:q.ui},{type:"vgroup",label:"Effect",items:U.ui}]}];else X.ui=[{type:"tgroup",label:"Polyphonic",items:[{type:"vgroup",label:"Voices",items:q.ui}]}];return X}getJSON(){return JSON.stringify(this.getMeta())}getUI(){return this.getMeta().ui}getDescriptors(){return this.fDescriptor}midiMessage(q){const U=q[0]>>4,X=q[0]&15,Y=q[1],Z=q[2];if(U===8||U===9&&Z===0)return this.keyOff(X,Y,Z);else if(U===9)return this.keyOn(X,Y,Z);else super.midiMessage(q)}ctrlChange(q,U,X){if(U===123||U===120)this.allNotesOff(!0);else super.ctrlChange(q,U,X)}keyOn(q,U,X){if(this.fPlotHandler)this.fCachedEvents.push({type:"keyOn",data:[q,U,X]});const Y=this.getFreeVoice();this.fVoiceTable[Y].keyOn(U,X,this.fVoiceTable[Y].fCurNote==g.kLegatoVoice)}keyOff(q,U,X){if(this.fPlotHandler)this.fCachedEvents.push({type:"keyOff",data:[q,U,X]});const Y=this.getPlayingVoice(U);if(Y!==g.kNoVoice)this.fVoiceTable[Y].keyOff();else console.log("Playing pitch = %d not found\n",U)}allNotesOff(q=!0){this.fCachedEvents.push({type:"ctrlChange",data:[0,123,0]}),this.fVoiceTable.forEach((U)=>U.keyOff(q))}},S0=class{constructor(Q,q){this.fDSPCode=Q,this.fBufferSize=q,this.fInputs=new Array(this.fDSPCode.getNumInputs()).fill(null).map(()=>new Float32Array(q)),this.fOutputs=new Array(this.fDSPCode.getNumOutputs()).fill(null).map(()=>new Float32Array(q))}getParameterDescriptors(){const Q=[],q=(U)=>{let X=null;const Y=["/gate","/freq","/gain","/key","/vel","/velocity"],Z="address"in U&&!!Y.find((J)=>U.address.endsWith(J));if(this.fDSPCode instanceof n||!Z){if(U.type==="vslider"||U.type==="hslider"||U.type==="nentry")X={name:U.address,defaultValue:U.init||0,minValue:U.min||0,maxValue:U.max||0};else if(U.type==="button"||U.type==="checkbox")X={name:U.address,defaultValue:U.init||0,minValue:0,maxValue:1}}if(X)Q.push(X)};return P.parseUI(this.fDSPCode.getUI(),q),Q}compute(Q,q){return this.fDSPCode.compute(Q,q)}setOutputParamHandler(Q){this.fDSPCode.setOutputParamHandler(Q)}getOutputParamHandler(){return this.fDSPCode.getOutputParamHandler()}setComputeHandler(Q){this.fDSPCode.setComputeHandler(Q)}getComputeHandler(){return this.fDSPCode.getComputeHandler()}setPlotHandler(Q){this.fDSPCode.setPlotHandler(Q)}getPlotHandler(){return this.fDSPCode.getPlotHandler()}getNumInputs(){return this.fDSPCode.getNumInputs()}getNumOutputs(){return this.fDSPCode.getNumOutputs()}metadata(Q){}midiMessage(Q){this.fDSPCode.midiMessage(Q)}ctrlChange(Q,q,U){this.fDSPCode.ctrlChange(Q,q,U)}pitchWheel(Q,q){this.fDSPCode.pitchWheel(Q,q)}setParamValue(Q,q){this.fDSPCode.setParamValue(Q,q)}getParamValue(Q){return this.fDSPCode.getParamValue(Q)}getParams(){return this.fDSPCode.getParams()}getMeta(){return this.fDSPCode.getMeta()}getJSON(){return this.fDSPCode.getJSON()}getDescriptors(){return this.fDSPCode.getDescriptors()}getUI(){return this.fDSPCode.getUI()}start(){this.fDSPCode.start()}stop(){this.fDSPCode.stop()}destroy(){this.fDSPCode.destroy()}get hasAccInput(){return this.fDSPCode.hasAccInput}propagateAcc(Q,q=!1){this.fDSPCode.propagateAcc(Q,q)}get hasGyrInput(){return this.fDSPCode.hasGyrInput}propagateGyr(Q){this.fDSPCode.propagateGyr(Q)}render(Q=[],q=this.fBufferSize,U){let X=0;const Y=new Array(this.fDSPCode.getNumOutputs()).fill(null).map(()=>new Float32Array(q));this.fDSPCode.start();while(X<q){const Z=Math.min(q-X,this.fBufferSize);for(let J=0;J<this.fDSPCode.getNumInputs();J++){let R;if(Q[J])if(Q[J].length<=X)R=new Float32Array(Z);else if(Q[J].length>X+Z)R=Q[J].subarray(X,X+Z);else R=Q[J].subarray(X,Q[J].length);else R=new Float32Array(Z);this.fInputs[J]=R}this.fDSPCode.compute(this.fInputs,this.fOutputs);for(let J=0;J<this.fDSPCode.getNumOutputs();J++){const R=this.fOutputs[J];if(Z<this.fBufferSize)Y[J].set(R.subarray(0,Z),X);else Y[J].set(R,X)}X+=this.fBufferSize,U==null||U(X)}return this.fDSPCode.stop(),Y}},kq=class extends S0{},Bq=class extends S0{keyOn(Q,q,U){this.fDSPCode.keyOn(Q,q,U)}keyOff(Q,q,U){this.fDSPCode.keyOff(Q,q,U)}allNotesOff(Q){this.fDSPCode.allNotesOff(Q)}};var jq=class{constructor(Q){this.fModule=Q,this.fCompiler=new Q.libFaustWasm,this.fFileSystem=this.fModule.FS}module(){return this.fModule}fs(){return this.fFileSystem}version(){return this.fCompiler.version()}createDSPFactory(Q,q,U,X){return this.fCompiler.createDSPFactory(Q,q,U,X)}deleteDSPFactory(Q){return this.fCompiler.deleteDSPFactory(Q)}expandDSP(Q,q,U){return this.fCompiler.expandDSP(Q,q,U)}generateAuxFiles(Q,q,U){return this.fCompiler.generateAuxFiles(Q,q,U)}deleteAllDSPFactories(){return this.fCompiler.deleteAllDSPFactories()}getErrorAfterException(){return this.fCompiler.getErrorAfterException()}cleanupAfterException(){return this.fCompiler.cleanupAfterException()}getInfos(Q){return this.fCompiler.getInfos(Q)}toString(){return`LibFaust module: ${this.fModule}, compiler: ${this.fCompiler}`}},b0=jq;var Hq=class{static get fallbackPaths(){return[location.href,this.getParentUrl(location.href),location.origin]}static getParentUrl(Q){return Q.substring(0,Q.lastIndexOf("/")+1)}static toAudioData(Q){const{sampleRate:q,numberOfChannels:U}=Q;return{sampleRate:q,audioBuffer:new Array(U).fill(null).map((X,Y)=>Q.getChannelData(Y))}}static findSoundfilesFromMeta(Q){const q={},U=(X)=>{if(X.type==="soundfile")P.splitSoundfileNames(X.url).forEach((Z)=>q[Z]=null)};return P.parseUI(Q.ui,U),q}static async checkFileExists(Q){try{console.log(`"checkFileExists" url: ${Q}`);const q=await fetch(Q);return console.log(`"checkFileExists" response.ok: ${q.ok}`),q.ok}catch(q){return console.error("Fetch error:",q),!1}}static async fetchSoundfile(Q,q){console.log(`Loading sound file from ${Q}`);const U=await fetch(Q);if(!U.ok)throw new Error(`Failed to load sound file from ${Q}: ${U.statusText}`);const X=await U.arrayBuffer(),Y=await q.decodeAudioData(X);return this.toAudioData(Y)}static async loadSoundfile(Q,q,U,X){if(U[Q])return;const Y=[Q,...[...q,...this.fallbackPaths].map((R)=>new URL(Q,R.endsWith("/")?R:`${R}/`).href)],J=(await Promise.all(Y.map((R)=>this.checkFileExists(R)))).findIndex((R)=>!!R);if(J===-1)throw new Error(`Failed to load sound file ${Q}, all check failed.`);U[Q]=await this.fetchSoundfile(Y[J],X)}static async loadSoundfiles(Q,q,U){const X=P.extractUrlsFromMeta(Q),Y=this.findSoundfilesFromMeta(Q);for(let Z in Y){if(q[Z]){Y[Z]=q[Z];continue}try{await this.loadSoundfile(Z,X,Y,U)}catch(J){console.error(J)}}return Y}},o=Hq,Y0,Z0,h0=class extends(globalThis.AudioWorkletNode||null){constructor(Q,q,U,X={}){const Y=JSON.parse(U.json);super(Q,q,{numberOfInputs:Y.inputs>0?1:0,numberOfOutputs:Y.outputs>0?1:0,channelCount:Math.max(1,Y.inputs),outputChannelCount:[Y.outputs],channelCountMode:"explicit",channelInterpretation:"speakers",processorOptions:X.processorOptions,...X});A0(this,Y0,!1),A0(this,Z0,!1),this.handleDeviceMotion=({accelerationIncludingGravity:Z})=>{const J=/Android/i.test(navigator.userAgent);if(!Z)return;const{x:R,y:K,z:T}=Z;this.propagateAcc({x:R,y:K,z:T},J)},this.handleDeviceOrientation=({alpha:Z,beta:J,gamma:R})=>{this.propagateGyr({alpha:Z,beta:J,gamma:R})},this.fJSONDsp=Y,this.fJSON=U.json,this.fOutputHandler=null,this.fComputeHandler=null,this.fPlotHandler=null,this.fDescriptor=[],this.fInputsItems=[],this.fUICallback=(Z)=>{if(Z.type==="vslider"||Z.type==="hslider"||Z.type==="button"||Z.type==="checkbox"||Z.type==="nentry"){if(this.fInputsItems.push(Z.address),this.fDescriptor.push(Z),!Z.meta)return;Z.meta.forEach((J)=>{const{midi:R,acc:K,gyr:T}=J;if(K)w0(this,Y0,!0);if(T)w0(this,Z0,!0)})}},P.parseUI(this.fJSONDsp.ui,this.fUICallback),this.port.onmessage=(Z)=>{if(Z.data.type==="param"&&this.fOutputHandler)this.fOutputHandler(Z.data.path,Z.data.value);else if(Z.data.type==="plot"&&this.fPlotHandler)this.fPlotHandler(Z.data.value,Z.data.index,Z.data.events)}}async startSensors(){if(this.hasAccInput)if(window.DeviceMotionEvent)if(typeof window.DeviceMotionEvent.requestPermission==="function")try{const Q=await window.DeviceMotionEvent.requestPermission();if(Q==="granted")window.addEventListener("devicemotion",this.handleDeviceMotion,!0);else if(Q==="denied")throw alert("You have denied access to motion and orientation data. To enable it, go to Settings > Safari > Motion & Orientation Access."),new Error("Unable to access the accelerometer.")}catch(Q){console.error(Q)}else window.addEventListener("devicemotion",this.handleDeviceMotion,!0);else console.log("Cannot set the accelerometer handler.");if(this.hasGyrInput)if(window.DeviceMotionEvent)if(typeof window.DeviceOrientationEvent.requestPermission==="function")try{const Q=await window.DeviceOrientationEvent.requestPermission();if(Q==="granted")window.addEventListener("deviceorientation",this.handleDeviceOrientation,!0);else if(Q==="denied")throw alert("You have denied access to motion and orientation data. To enable it, go to Settings > Safari > Motion & Orientation Access."),new Error("Unable to access the gyroscope.")}catch(Q){console.error(Q)}else window.addEventListener("deviceorientation",this.handleDeviceOrientation,!0);else console.log("Cannot set the gyroscope handler.")}stopSensors(){if(this.hasAccInput)window.removeEventListener("devicemotion",this.handleDeviceMotion,!0);if(this.hasGyrInput)window.removeEventListener("deviceorientation",this.handleDeviceOrientation,!0)}setOutputParamHandler(Q){this.fOutputHandler=Q}getOutputParamHandler(){return this.fOutputHandler}setComputeHandler(Q){this.fComputeHandler=Q}getComputeHandler(){return this.fComputeHandler}setPlotHandler(Q){if(this.fPlotHandler=Q,this.fPlotHandler)this.port.postMessage({type:"setPlotHandler",data:!0});else this.port.postMessage({type:"setPlotHandler",data:!1})}getPlotHandler(){return this.fPlotHandler}setupWamEventHandler(){this.port.postMessage({type:"setupWamEventHandler"})}getNumInputs(){return this.fJSONDsp.inputs}getNumOutputs(){return this.fJSONDsp.outputs}compute(Q,q){return!1}metadata(Q){if(this.fJSONDsp.meta)this.fJSONDsp.meta.forEach((q)=>Q(Object.keys(q)[0],q[Object.keys(q)[0]]))}midiMessage(Q){const q=Q[0]>>4,U=Q[0]&15,X=Q[1],Y=Q[2];if(q===11)this.ctrlChange(U,X,Y);else if(q===14)this.pitchWheel(U,Y*128+X);else this.port.postMessage({type:"midi",data:Q})}ctrlChange(Q,q,U){const X={type:"ctrlChange",data:[Q,q,U]};this.port.postMessage(X)}pitchWheel(Q,q){const U={type:"pitchWheel",data:[Q,q]};this.port.postMessage(U)}get hasAccInput(){return M0(this,Y0)}propagateAcc(Q,q=!1){if(!Q)return;const U={type:"acc",data:Q,invert:q};this.port.postMessage(U)}get hasGyrInput(){return M0(this,Z0)}propagateGyr(Q){if(!Q)return;const q={type:"gyr",data:Q};this.port.postMessage(q)}setParamValue(Q,q){const U={type:"param",data:{path:Q,value:q}};this.port.postMessage(U);const X=this.parameters.get(Q);if(X)X.setValueAtTime(q,this.context.currentTime)}getParamValue(Q){const q=this.parameters.get(Q);return q?q.value:0}getParams(){return this.fInputsItems}getMeta(){return this.fJSONDsp}getJSON(){return JSON.stringify(this.getMeta())}getUI(){return this.fJSONDsp.ui}getDescriptors(){return this.fDescriptor}start(){this.port.postMessage({type:"start"})}stop(){this.port.postMessage({type:"stop"})}destroy(){this.port.postMessage({type:"destroy"}),this.port.close()}};Y0=new WeakMap;Z0=new WeakMap;var D0=class extends h0{constructor(Q,q){super(Q,q.processorOptions.name,q.processorOptions.factory,q);this.onprocessorerror=(U)=>{throw U}}},$q=class extends h0{constructor(Q,q){super(Q,q.processorOptions.name,q.processorOptions.voiceFactory,q);if(this.onprocessorerror=(U)=>{throw U},this.fJSONEffect=q.processorOptions.effectFactory?JSON.parse(q.processorOptions.effectFactory.json):null,this.fJSONEffect)P.parseUI(this.fJSONEffect.ui,this.fUICallback)}keyOn(Q,q,U){const X={type:"keyOn",data:[Q,q,U]};this.port.postMessage(X)}keyOff(Q,q,U){const X={type:"keyOff",data:[Q,q,U]};this.port.postMessage(X)}allNotesOff(Q){const q={type:"ctrlChange",data:[0,123,0]};this.port.postMessage(q)}getMeta(){const Q=this.fJSONDsp,q=this.fJSONEffect,U={...Q};if(q)U.ui=[{type:"tgroup",label:"Sequencer",items:[{type:"vgroup",label:"Instrument",items:Q.ui},{type:"vgroup",label:"Effect",items:q.ui}]}];else U.ui=[{type:"tgroup",label:"Polyphonic",items:[{type:"vgroup",label:"Voices",items:Q.ui}]}];return U}getJSON(){return JSON.stringify(this.getMeta())}getUI(){return this.getMeta().ui}},F0=class extends(globalThis.ScriptProcessorNode||null){constructor(){super(...arguments);this.handleDeviceMotion=void 0,this.handleDeviceOrientation=void 0}init(Q){this.fDSPCode=Q,this.fInputs=new Array(this.fDSPCode.getNumInputs()),this.fOutputs=new Array(this.fDSPCode.getNumOutputs()),this.handleDeviceMotion=({accelerationIncludingGravity:q})=>{const U=/Android/i.test(navigator.userAgent);if(!q)return;const{x:X,y:Y,z:Z}=q;this.propagateAcc({x:X,y:Y,z:Z},U)},this.handleDeviceOrientation=({alpha:q,beta:U,gamma:X})=>{this.propagateGyr({alpha:q,beta:U,gamma:X})},this.onaudioprocess=(q)=>{for(let U=0;U<this.fDSPCode.getNumInputs();U++)this.fInputs[U]=q.inputBuffer.getChannelData(U);for(let U=0;U<this.fDSPCode.getNumOutputs();U++)this.fOutputs[U]=q.outputBuffer.getChannelData(U);return this.fDSPCode.compute(this.fInputs,this.fOutputs)},this.start()}async startSensors(){if(this.hasAccInput)if(window.DeviceMotionEvent)if(typeof window.DeviceMotionEvent.requestPermission==="function")try{const Q=await window.DeviceMotionEvent.requestPermission();if(Q==="granted")window.addEventListener("devicemotion",this.handleDeviceMotion,!0);else if(Q==="denied")throw alert("You have denied access to motion and orientation data. To enable it, go to Settings > Safari > Motion & Orientation Access."),new Error("Unable to access the accelerometer.")}catch(Q){console.error(Q)}else window.addEventListener("devicemotion",this.handleDeviceMotion,!0);else console.log("Cannot set the accelerometer handler.");if(this.hasGyrInput)if(window.DeviceMotionEvent)if(typeof window.DeviceOrientationEvent.requestPermission==="function")try{const Q=await window.DeviceOrientationEvent.requestPermission();if(Q==="granted")window.addEventListener("deviceorientation",this.handleDeviceOrientation,!0);else if(Q==="denied")throw alert("You have denied access to motion and orientation data. To enable it, go to Settings > Safari > Motion & Orientation Access."),new Error("Unable to access the gyroscope.")}catch(Q){console.error(Q)}else window.addEventListener("deviceorientation",this.handleDeviceOrientation,!0);else console.log("Cannot set the gyroscope handler.")}stopSensors(){if(this.hasAccInput)window.removeEventListener("devicemotion",this.handleDeviceMotion,!0);if(this.hasGyrInput)window.removeEventListener("deviceorientation",this.handleDeviceOrientation,!0)}compute(Q,q){return this.fDSPCode.compute(Q,q)}setOutputParamHandler(Q){this.fDSPCode.setOutputParamHandler(Q)}getOutputParamHandler(){return this.fDSPCode.getOutputParamHandler()}setComputeHandler(Q){this.fDSPCode.setComputeHandler(Q)}getComputeHandler(){return this.fDSPCode.getComputeHandler()}setPlotHandler(Q){this.fDSPCode.setPlotHandler(Q)}getPlotHandler(){return this.fDSPCode.getPlotHandler()}getNumInputs(){return this.fDSPCode.getNumInputs()}getNumOutputs(){return this.fDSPCode.getNumOutputs()}metadata(Q){}midiMessage(Q){this.fDSPCode.midiMessage(Q)}ctrlChange(Q,q,U){this.fDSPCode.ctrlChange(Q,q,U)}pitchWheel(Q,q){this.fDSPCode.pitchWheel(Q,q)}setParamValue(Q,q){this.fDSPCode.setParamValue(Q,q)}getParamValue(Q){return this.fDSPCode.getParamValue(Q)}getParams(){return this.fDSPCode.getParams()}getMeta(){return this.fDSPCode.getMeta()}getJSON(){return this.fDSPCode.getJSON()}getDescriptors(){return this.fDSPCode.getDescriptors()}getUI(){return this.fDSPCode.getUI()}start(){this.fDSPCode.start()}stop(){this.fDSPCode.stop()}destroy(){this.fDSPCode.destroy()}get hasAccInput(){return this.fDSPCode.hasAccInput}propagateAcc(Q,q=!1){this.fDSPCode.propagateAcc(Q,q)}get hasGyrInput(){return this.fDSPCode.hasGyrInput}propagateGyr(Q){this.fDSPCode.propagateGyr(Q)}},Oq=class extends F0{},Iq=class extends F0{keyOn(Q,q,U){this.fDSPCode.keyOn(Q,q,U)}keyOff(Q,q,U){this.fDSPCode.keyOff(Q,q,U)}allNotesOff(Q){this.fDSPCode.allNotesOff(Q)}},Mq=class Q{constructor(){this.factory=null}async compile(q,U,X,Y){if(this.factory=await q.createMonoDSPFactory(U,X,Y),this.factory)return this.name=U,this;else return null}addSoundfiles(q){if(!this.factory)throw new Error("Code is not compiled, please define the factory or call `await this.compile()` first.");for(let U in q)this.factory.soundfiles[U]=q[U]}getSoundfileList(){if(!this.factory)throw new Error("Code is not compiled, please define the factory or call `await this.compile()` first.");const q=JSON.parse(this.factory.json),U=o.findSoundfilesFromMeta(q);return Object.keys(U)}async createNode(q,U=this.name,X=this.factory,Y=!1,Z=1024,J=(X==null?void 0:X.shaKey)||U,R={}){var K,T;if(!X)throw new Error("Code is not compiled, please define the factory or call `await this.compile()` first.");const G=JSON.parse(X.json),E=G.compile_options.match("-double")?8:4;if(X.soundfiles=await o.loadSoundfiles(G,X.soundfiles||{},q),Y){const W=await l.createAsyncMonoDSPInstance(X),V=new n(W,q.sampleRate,E,Z,X.soundfiles),w=q.createScriptProcessor(Z,V.getNumInputs(),V.getNumOutputs());return Object.setPrototypeOf(w,Oq.prototype),w.init(V),w}else{if(!Q.gWorkletProcessors.has(q))Q.gWorkletProcessors.set(q,new Set);if(!((K=Q.gWorkletProcessors.get(q))==null?void 0:K.has(J)))try{const V=`
// DSP name and JSON string for DSP are generated
const faustData = ${JSON.stringify({processorName:J,dspName:U,dspMeta:G,poly:!1})};
// Implementation needed classes of functions
var ${s.name} = ${s.toString()}
var FaustDspInstance = ${s.name};
var ${P.name} = ${P.toString()}
var FaustBaseWebAudioDsp = ${P.name};
var ${n.name} = ${n.toString()}
var FaustMonoWebAudioDsp = ${n.name};
var ${l.name} = ${l.toString()}
var FaustWasmInstantiator = ${l.name};
var ${f.name} = ${f.toString()}
var Soundfile = ${f.name};
var ${m.name} = ${m.toString()}
var WasmAllocator = ${m.name};
var ${d.name} = ${d.toString()}
var FaustSensors = ${d.name};
// Put them in dependencies
const dependencies = {
    FaustBaseWebAudioDsp,
    FaustMonoWebAudioDsp,
    FaustWasmInstantiator
};
// Generate the actual AudioWorkletProcessor code
(${J0.toString()})(dependencies, faustData);
`,w=URL.createObjectURL(new Blob([V],{type:"text/javascript"}));await q.audioWorklet.addModule(w),(T=Q.gWorkletProcessors.get(q))==null||T.add(J)}catch(V){throw V}return new D0(q,{processorOptions:{name:J,factory:X,sampleSize:E,...R}})}}async createFFTNode(q,U,X=this.name,Y=this.factory,Z={},J=(Y==null?void 0:Y.shaKey)?`${Y.shaKey}_fft`:X,R={}){var K,T;if(!Y)throw new Error("Code is not compiled, please define the factory or call `await this.compile()` first.");const G=JSON.parse(Y.json),E=G.compile_options.match("-double")?8:4;if(Y.soundfiles=await o.loadSoundfiles(G,Y.soundfiles||{},q),!Q.gWorkletProcessors.has(q))Q.gWorkletProcessors.set(q,new Set);if(!((K=Q.gWorkletProcessors.get(q))==null?void 0:K.has(J)))try{const V=`
// DSP name and JSON string for DSP are generated
const faustData = ${JSON.stringify({processorName:J,dspName:X,dspMeta:G,fftOptions:Z})};
// Implementation needed classes of functions
var ${s.name} = ${s.toString()}
var FaustDspInstance = ${s.name};
var ${P.name} = ${P.toString()}
var FaustBaseWebAudioDsp = ${P.name};
var ${n.name} = ${n.toString()}
var FaustMonoWebAudioDsp = ${n.name};
var ${l.name} = ${l.toString()}
var FaustWasmInstantiator = ${l.name};
var ${f.name} = ${f.toString()}
var Soundfile = ${f.name};
var ${m.name} = ${m.toString()}
var WasmAllocator = ${m.name};
var ${d.name} = ${d.toString()}
var FaustSensors = ${d.name};
var FFTUtils = ${U.toString()}
// Put them in dependencies
const dependencies = {
    FaustBaseWebAudioDsp,
    FaustMonoWebAudioDsp,
    FaustWasmInstantiator,
    FFTUtils
};
// Generate the actual AudioWorkletProcessor code
(${e0.toString()})(dependencies, faustData);
`,w=URL.createObjectURL(new Blob([V],{type:"text/javascript"}));await q.audioWorklet.addModule(w),(T=Q.gWorkletProcessors.get(q))==null||T.add(J)}catch(V){throw V}const W=new D0(q,{channelCount:Math.max(1,Math.ceil(G.inputs/3)),outputChannelCount:[Math.ceil(G.outputs/2)],processorOptions:{name:J,factory:Y,sampleSize:E,...R}});if(Z.fftSize){const V=W.parameters.get("fftSize");if(V)V.value=Z.fftSize}if(Z.fftOverlap){const V=W.parameters.get("fftOverlap");if(V)V.value=Z.fftOverlap}if(typeof Z.defaultWindowFunction==="number"){const V=W.parameters.get("windowFunction");if(V)V.value=Z.defaultWindowFunction+1}if(typeof Z.noIFFT==="boolean"){const V=W.parameters.get("noIFFT");if(V)V.value=+Z.noIFFT}return W}async createAudioWorkletProcessor(q=this.name,U=this.factory,X=(U==null?void 0:U.shaKey)||q){if(!U)throw new Error("Code is not compiled, please define the factory or call `await this.compile()` first.");const Y=JSON.parse(U.json),Z={FaustBaseWebAudioDsp:P,FaustMonoWebAudioDsp:n,FaustWasmInstantiator:l,FaustPolyWebAudioDsp:void 0,FaustWebAudioDspVoice:void 0};try{return J0(Z,{processorName:X,dspName:q,dspMeta:Y,poly:!1})}catch(J){throw J}}async createOfflineProcessor(q,U,X=this.factory,Y){if(!X)throw new Error("Code is not compiled, please define the factory or call `await this.compile()` first.");const Z=JSON.parse(X.json),J=await l.createAsyncMonoDSPInstance(X),R=Z.compile_options.match("-double")?8:4;if(Y)X.soundfiles=await o.loadSoundfiles(Z,X.soundfiles||{},Y);const K=new n(J,q,R,U,X.soundfiles);return new kq(K,U)}getMeta(){return JSON.parse(this.factory.json)}getJSON(){return JSON.stringify(this.getMeta())}getUI(){return this.getMeta().ui}};Mq.gWorkletProcessors=new Map;var Aq=class Q{constructor(){this.voiceFactory=null,this.effectFactory=null}async compile(q,U,X,Y,Z=`dsp_code = environment{
                ${X}
            };
            process = dsp_code.effect;`){try{if(this.effectFactory=await q.createPolyDSPFactory(U,Z,Y),this.effectFactory){const J=JSON.parse(this.effectFactory.json),R=`// Voice output is forced to 2, when DSP is stereo or effect has 2 ins or 2 outs,
// so that the effect can process the 2 channels of the voice
adaptOut(1,1,1) = _;
adaptOut(1,1,2) = _ <: _,0;  // The left channel only is kept
adaptOut(1,2,1) = _ <: _,_;
adaptOut(1,2,2) = _ <: _,_;
adaptOut(2,1,1) = _,_;
adaptOut(2,1,2) = _,_;
adaptOut(2,2,1) = _,_;
adaptOut(2,2,2) = _,_;
adaptor(F) = adaptOut(outputs(F),${J.inputs},${J.outputs});
dsp_code = environment{
    ${X}
};
process = dsp_code.process : adaptor(dsp_code.process);
`,K=`// Inputs
adaptIn(1,1,1) = _;
adaptIn(1,1,2) = _,_ :> _;  
adaptIn(1,2,1) = _,_;
adaptIn(1,2,2) = _,_;
adaptIn(2,1,1) = _,_ :> _;
adaptIn(2,1,2) = _,_ :> _;
adaptIn(2,2,1) = _,_;
adaptIn(2,2,2) = _,_;
// Outputs
adaptOut(1,1) = _ <: _,0;   // The left channel only is kept
adaptOut(1,2) = _,_;
adaptOut(2,1) = _ <: _,0;   // The left channel only is kept
adaptOut(2,2) = _,_;
adaptorIns(F) = adaptIn(outputs(F),${J.inputs},${J.outputs});
adaptorOuts = adaptOut(${J.inputs},${J.outputs});
dsp_code = environment{
    ${X}
};
process = adaptorIns(dsp_code.process) : dsp_code.effect : adaptorOuts;
`;this.voiceFactory=await q.createPolyDSPFactory(U,R,Y);try{this.effectFactory=await q.createPolyDSPFactory(U,K,Y+" -inpl")}catch(T){console.warn(T)}}}catch(J){console.warn(J),this.voiceFactory=await q.createPolyDSPFactory(U,X,Y)}if(this.voiceFactory){this.name=U;const R=JSON.parse(this.voiceFactory.json).compile_options.match("-double"),{mixerBuffer:K,mixerModule:T}=await q.getAsyncInternalMixerModule(!!R);return this.mixerBuffer=K,this.mixerModule=T,this}else return null}addSoundfiles(q){if(!this.voiceFactory)throw new Error("Code is not compiled, please define the factory or call `await this.compile()` first.");for(let U in q)this.voiceFactory.soundfiles[U]=q[U]}getSoundfileList(){if(!this.voiceFactory)throw new Error("Code is not compiled, please define the factory or call `await this.compile()` first.");const q=JSON.parse(this.voiceFactory.json),U=o.findSoundfilesFromMeta(q);if(!this.effectFactory)return Object.keys(U);const X=JSON.parse(this.effectFactory.json),Y=o.findSoundfilesFromMeta(X);return Object.keys({...Y,...U})}async createNode(q,U,X=this.name,Y=this.voiceFactory,Z=this.mixerModule,J=this.effectFactory,R=!1,K=1024,T=((Y==null?void 0:Y.shaKey)||"")+((J==null?void 0:J.shaKey)||"")||`${X}_poly`,G={}){var E,W;if(!Y)throw new Error("Code is not compiled, please define the factory or call `await this.compile()` first.");const V=JSON.parse(Y.json),w=J?JSON.parse(J.json):void 0,F=V.compile_options.match("-double")?8:4;if(Y.soundfiles=await o.loadSoundfiles(V,Y.soundfiles||{},q),J)J.soundfiles=await o.loadSoundfiles(w,J.soundfiles||{},q);if(R){const C=await l.createAsyncPolyDSPInstance(Y,Z,U,J||void 0),S={...J==null?void 0:J.soundfiles,...Y.soundfiles},L=new e(C,q.sampleRate,F,K,S),k=q.createScriptProcessor(K,L.getNumInputs(),L.getNumOutputs());return Object.setPrototypeOf(k,Iq.prototype),k.init(L),k}else{if(!Q.gWorkletProcessors.has(q))Q.gWorkletProcessors.set(q,new Set);if(!((E=Q.gWorkletProcessors.get(q))==null?void 0:E.has(T)))try{const S=`
// DSP name and JSON string for DSP are generated
const faustData = ${JSON.stringify({processorName:T,dspName:X,dspMeta:V,poly:!0,effectMeta:w})};
// Implementation needed classes of functions
var ${s.name} = ${s.toString()}
var FaustDspInstance = ${s.name};
var ${P.name} = ${P.toString()}
var FaustBaseWebAudioDsp = ${P.name};
var ${e.name} = ${e.toString()}
var FaustPolyWebAudioDsp = ${e.name};
var ${g.name} = ${g.toString()}
var FaustWebAudioDspVoice = ${g.name};
var ${l.name} = ${l.toString()}
var FaustWasmInstantiator = ${l.name};
var ${f.name} = ${f.toString()}
var Soundfile = ${f.name};
var ${m.name} = ${m.toString()}
var WasmAllocator = ${m.name};
var ${d.name} = ${d.toString()}
var FaustSensors = ${d.name};
// Put them in dependencies
const dependencies = {
    FaustBaseWebAudioDsp,
    FaustPolyWebAudioDsp,
    FaustWasmInstantiator
};
// Generate the actual AudioWorkletProcessor code
(${J0.toString()})(dependencies, faustData);
`,L=URL.createObjectURL(new Blob([S],{type:"text/javascript"}));await q.audioWorklet.addModule(L),(W=Q.gWorkletProcessors.get(q))==null||W.add(T)}catch(S){throw S}return new $q(q,{processorOptions:{name:T,voiceFactory:Y,mixerModule:Z,voices:U,sampleSize:F,effectFactory:J||void 0,...G}})}}async createAudioWorkletProcessor(q=this.name,U=this.voiceFactory,X=this.effectFactory,Y=((U==null?void 0:U.shaKey)||"")+((X==null?void 0:X.shaKey)||"")||`${q}_poly`){if(!U)throw new Error("Code is not compiled, please define the factory or call `await this.compile()` first.");const Z=JSON.parse(U.json),J=X?JSON.parse(X.json):void 0,R=Z.compile_options.match("-double")?8:4;try{return J0({FaustBaseWebAudioDsp:P,FaustMonoWebAudioDsp:void 0,FaustWasmInstantiator:l,FaustPolyWebAudioDsp:e,FaustWebAudioDspVoice:g},{processorName:Y,dspName:q,dspMeta:Z,poly:!0,effectMeta:J})}catch(K){throw K}}async createOfflineProcessor(q,U,X,Y=this.voiceFactory,Z=this.mixerModule,J=this.effectFactory,R){if(!Y)throw new Error("Code is not compiled, please define the factory or call `await this.compile()` first.");const K=JSON.parse(Y.json),T=J?JSON.parse(J.json):void 0,G=await l.createAsyncPolyDSPInstance(Y,Z,X,J||void 0),E=K.compile_options.match("-double")?8:4;if(R){if(Y.soundfiles=await o.loadSoundfiles(K,Y.soundfiles||{},R),J)J.soundfiles=await o.loadSoundfiles(T,J.soundfiles||{},R)}const W={...J==null?void 0:J.soundfiles,...Y.soundfiles},V=new e(G,q,E,U,W);return new Bq(V,U)}getMeta(){const q=this.voiceFactory?JSON.parse(this.voiceFactory.json):null,U=this.effectFactory?JSON.parse(this.effectFactory.json):null,X={...q};if(U)X.ui=[{type:"tgroup",label:"Sequencer",items:[{type:"vgroup",label:"Instrument",items:q.ui},{type:"vgroup",label:"Effect",items:U.ui}]}];else X.ui=[{type:"tgroup",label:"Polyphonic",items:[{type:"vgroup",label:"Voices",items:q.ui}]}];return X}getJSON(){return JSON.stringify(this.getMeta())}getUI(){return this.getMeta().ui}};Aq.gWorkletProcessors=new Map;async function wq(Q,q){const U=[Q.source].flat();return await new Promise(async(X,Y)=>{if(Q.sourceTransformer){const Z=new URL(Q.sourceTransformer,q).href,J=new Array(U.length);let R=U.length;globalThis.cmaj_sendMessageToServer=async(T)=>{switch(T.type){case"ready":{for(let G=0;G<U.length;G++){const E=U[G],W=new URL(E,q).href,V=await fetch(W).then((w)=>w.text());globalThis.currentView.deliverMessageFromServer({type:"transformRequest",message:{requestId:G,filename:W,contents:V}})}break}case"transformResponse":{if(T.message?.requestId===void 0){console.error("Invalid response",T);return}if(J[T.message.requestId]=T.message.contents,R--,R===0){const G=Object.fromEntries(U.map((E,W)=>[E,J[W]]));X(G)}break}}},(await import(Z)).default()}else{const Z=Object.fromEntries(await Promise.all(U.map(async(J)=>{const R=new URL(J,q).href,K=await fetch(R).then((T)=>T.text());return[J,K]})));X(Z)}})}globalThis.window=globalThis;self.onmessage=async function(Q){const q=Q.data.manifest,U=Q.data.url,X=Q.data.faustModuleUrl,Y=await wq(q,U);for(let[Z,J]of Object.entries(Y))if(Z.endsWith(".dsp")){if(!J.includes("namespace")&&!J.includes("processor")){const R=await z0(X),K=new b0(R);globalThis.libFaust=K;const T=new g0(K),G=Z.split("/").at(-1).split(".")[0].trim(),E=["-lang cmajor-hybrid -cn "+G+" -o foo.cmajor"],W=J;if(T.generateAuxFiles(G,W,E.join(" "))){const w=T.fs().readFile("foo.cmajor",{encoding:"utf8"});Y[Z]=w}else console.log("ooops")}}self.postMessage({files:Y})};

//# debugId=CAF20A5C6291157C64756E2164756E21
//# sourceMappingURL=transformer.worker.js.map
